
# This is a random torch model generated by the following modules: ['PairwiseDistance', 'ReplicationPad1d', 'CrossEntropyLoss', 'CELU', 'GroupNorm', 'BatchNorm1d', 'LogSoftmax', 'MaxPool3d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.replication_pad1d = nn.ReplicationPad1d(2)
        self.celu = nn.CELU()
        self.group_norm = nn.GroupNorm(2, 4)
        self.batch_norm1d = nn.BatchNorm1d(8)
        self.max_pool3d = nn.MaxPool3d(kernel_size=2)
        self.log_softmax = nn.LogSoftmax(dim=1)
        self.cross_entropy_loss = nn.CrossEntropyLoss()

    def forward(self, x):
        # Assuming input x is of shape (batch_size, channels, depth, height, width)
        x = self.max_pool3d(x)  # Apply MaxPool3d
        x = x.view(x.size(0), x.size(1), -1)  # Flatten spatial dimensions
        x = self.replication_pad1d(x)  # Apply ReplicationPad1d
        x = self.celu(x)  # Apply CELU
        x = x.view(x.size(0), -1)  # Flatten to (batch_size, features)
        x = self.batch_norm1d(x)  # Apply BatchNorm1d
        x = x.view(x.size(0), 4, -1)  # Reshape for GroupNorm
        x = self.group_norm(x)  # Apply GroupNorm
        x = x.view(x.size(0), -1)  # Flatten to (batch_size, features)
        x = self.log_softmax(x)  # Apply LogSoftmax
        
        # For PairwiseDistance, we need two inputs
        y = torch.randn_like(x)  # Random tensor for PairwiseDistance
        pairwise_distance = F.pairwise_distance(x, y)  # Apply PairwiseDistance
        
        # For CrossEntropyLoss, we need a target
        target = torch.randint(0, x.size(1), (x.size(0),))  # Random target
        loss = self.cross_entropy_loss(x, target)  # Apply CrossEntropyLoss
        
        return loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 4, 16, 16, 16).cuda()  # Example input shape
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


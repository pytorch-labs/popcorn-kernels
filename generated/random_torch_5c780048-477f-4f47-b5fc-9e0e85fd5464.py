
# This is a random torch model generated by the following modules: ['UpsamplingBilinear2d', 'Bilinear', 'ELU', 'AvgPool3d', 'NLLLoss2d', 'MaxUnpool2d', 'PoissonNLLLoss', 'CosineEmbeddingLoss']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.upsample = nn.UpsamplingBilinear2d(scale_factor=2)
        self.bilinear = nn.Bilinear(10, 20, 30)
        self.elu = nn.ELU()
        self.avgpool3d = nn.AvgPool3d(kernel_size=2)
        self.nllloss2d = nn.NLLLoss()
        self.maxunpool2d = nn.MaxUnpool2d(kernel_size=2, stride=2)
        self.poissonnllloss = nn.PoissonNLLLoss()
        self.cosineembeddingloss = nn.CosineEmbeddingLoss()

    def forward(self, x):
        # Upsample the input
        x = self.upsample(x)
        
        # Reshape for AvgPool3d
        x = x.unsqueeze(1)  # Add a channel dimension
        x = self.avgpool3d(x)
        
        # Reshape for Bilinear
        x = x.view(-1, 10, 20)  # Reshape to (batch_size, 10, 20)
        x = self.bilinear(x[:, :, :10], x[:, :, 10:])
        
        # Apply ELU activation
        x = self.elu(x)
        
        # Reshape for MaxUnpool2d
        x = x.view(-1, 30, 8, 8)  # Reshape to (batch_size, 30, 8, 8)
        indices = torch.randint(0, 8, (x.size(0), 30, 4, 4)).to(x.device)
        x = self.maxunpool2d(x, indices)
        
        # Compute NLLLoss2d (dummy target)
        target = torch.randint(0, 30, (x.size(0), x.size(2), x.size(3))).to(x.device)
        x = self.nllloss2d(F.log_softmax(x, dim=1), target)
        
        # Compute PoissonNLLLoss (dummy target)
        target_poisson = torch.randn_like(x).abs()
        x = self.poissonnllloss(x, target_poisson)
        
        # Compute CosineEmbeddingLoss (dummy inputs)
        input1 = torch.randn_like(x)
        input2 = torch.randn_like(x)
        target_cosine = torch.ones(x.size(0)).to(x.device)
        x = self.cosineembeddingloss(input1, input2, target_cosine)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 32, 32).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


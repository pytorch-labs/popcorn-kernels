
# This is a random torch model generated by the following modules: ['ModuleList', 'AdaptiveMaxPool2d', 'LayerNorm', 'ReplicationPad3d', 'SiLU']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.module_list = nn.ModuleList([
            nn.Sequential(
                nn.ReplicationPad3d(1),
                nn.AdaptiveMaxPool2d((16, 16)),
                nn.LayerNorm([16, 16]),
                nn.SiLU()
            ) for _ in range(5)
        ])
        self.final_layer_norm = nn.LayerNorm([16, 16])

    def forward(self, x):
        # Assuming input is 4D (batch, channels, height, width)
        # If input is 3D, reshape to 4D
        if x.dim() == 3:
            x = x.unsqueeze(1)  # Add channel dimension
        
        # Apply each module in the ModuleList
        for module in self.module_list:
            x = module(x)
        
        # Apply final LayerNorm
        x = self.final_layer_norm(x)
        
        # Flatten the output
        x = x.view(x.size(0), -1)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 32, 32).cuda()  # Example input with batch size 1, 3 channels, 32x32 spatial dimensions
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []



# This is a random torch model generated by the following modules: ['Conv3d', 'PixelShuffle', 'SyncBatchNorm', 'Dropout2d', 'Conv2d', 'LogSigmoid', 'TripletMarginWithDistanceLoss', 'Softshrink', 'AvgPool2d', 'PixelUnshuffle']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.conv3d_1 = nn.Conv3d(1, 10, kernel_size=(3, 3, 3))
        self.pixel_shuffle_1 = nn.PixelShuffle(2)
        self.sync_bn_1 = nn.SyncBatchNorm(10)
        self.dropout2d_1 = nn.Dropout2d(0.5)
        self.conv2d_1 = nn.Conv2d(10, 20, kernel_size=5)
        self.log_sigmoid = nn.LogSigmoid()
        self.softshrink = nn.Softshrink(0.5)
        self.avg_pool2d = nn.AvgPool2d(kernel_size=2)
        self.pixel_unshuffle = nn.PixelUnshuffle(2)
        self.conv3d_2 = nn.Conv3d(20, 30, kernel_size=(3, 3, 3))
        self.sync_bn_2 = nn.SyncBatchNorm(30)
        self.dropout2d_2 = nn.Dropout2d(0.5)
        self.conv2d_2 = nn.Conv2d(30, 40, kernel_size=5)
        self.triplet_loss = nn.TripletMarginWithDistanceLoss(distance_function=lambda x, y: F.pairwise_distance(x, y, p=2))

    def forward(self, x):
        # Initial 3D convolution
        x = self.conv3d_1(x)
        
        # Reshape for PixelShuffle
        x = x.squeeze(2)  # Remove the depth dimension
        x = self.pixel_shuffle_1(x)
        
        # SyncBatchNorm
        x = self.sync_bn_1(x)
        
        # Dropout2d
        x = self.dropout2d_1(x)
        
        # 2D Convolution
        x = self.conv2d_1(x)
        
        # LogSigmoid
        x = self.log_sigmoid(x)
        
        # Softshrink
        x = self.softshrink(x)
        
        # AvgPool2d
        x = self.avg_pool2d(x)
        
        # PixelUnshuffle
        x = self.pixel_unshuffle(x)
        
        # Reshape back to 3D for Conv3d
        x = x.unsqueeze(2)  # Add the depth dimension back
        
        # Second 3D convolution
        x = self.conv3d_2(x)
        
        # SyncBatchNorm
        x = self.sync_bn_2(x)
        
        # Dropout2d
        x = self.dropout2d_2(x)
        
        # Final 2D Convolution
        x = x.squeeze(2)  # Remove the depth dimension
        x = self.conv2d_2(x)
        
        # TripletMarginWithDistanceLoss (requires anchor, positive, and negative samples)
        anchor = x[:x.size(0)//3]
        positive = x[x.size(0)//3:2*x.size(0)//3]
        negative = x[2*x.size(0)//3:]
        loss = self.triplet_loss(anchor, positive, negative)
        
        return loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(9, 1, 16, 64, 64).cuda()  # Batch size 9 to allow for triplet loss
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []



# This is a random torch model generated by the following modules: ['ModuleList', 'Sigmoid', 'LogSigmoid', 'AdaptiveAvgPool3d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        # Using ModuleList to store multiple AdaptiveAvgPool3d layers
        self.pool_layers = nn.ModuleList([
            nn.AdaptiveAvgPool3d((8, 8, 8)) for _ in range(3)
        ])
        # Using ModuleList to store multiple Sigmoid and LogSigmoid layers
        self.activation_layers = nn.ModuleList([
            nn.Sigmoid(),
            nn.LogSigmoid(),
            nn.Sigmoid(),
            nn.LogSigmoid(),
            nn.Sigmoid()
        ])

    def forward(self, x):
        # Apply the first AdaptiveAvgPool3d layer
        x = self.pool_layers[0](x)
        
        # Apply the first Sigmoid activation
        x = self.activation_layers[0](x)
        
        # Apply the second AdaptiveAvgPool3d layer
        x = self.pool_layers[1](x)
        
        # Apply the first LogSigmoid activation
        x = self.activation_layers[1](x)
        
        # Apply the third AdaptiveAvgPool3d layer
        x = self.pool_layers[2](x)
        
        # Apply the second Sigmoid activation
        x = self.activation_layers[2](x)
        
        # Apply the second LogSigmoid activation
        x = self.activation_layers[3](x)
        
        # Apply the third Sigmoid activation
        x = self.activation_layers[4](x)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 16, 16, 16).cuda()  # Example input with shape (batch_size, channels, depth, height, width)
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

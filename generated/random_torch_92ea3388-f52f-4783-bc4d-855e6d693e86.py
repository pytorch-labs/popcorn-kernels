
# This is a random torch model generated by the following modules: ['MaxUnpool1d', 'TransformerEncoder', 'FeatureAlphaDropout', 'Bilinear']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.max_unpool1d = nn.MaxUnpool1d(kernel_size=2, stride=2)
        self.transformer_encoder = nn.TransformerEncoder(
            nn.TransformerEncoderLayer(d_model=64, nhead=8), num_layers=3
        )
        self.feature_alpha_dropout = nn.FeatureAlphaDropout(p=0.5)
        self.bilinear = nn.Bilinear(64, 64, 128)

    def forward(self, x):
        # Assuming x is of shape (batch_size, channels, sequence_length)
        batch_size, channels, sequence_length = x.shape
        
        # Apply MaxUnpool1d (requires indices from a previous MaxPool1d operation)
        # For simplicity, we'll assume the indices are available from a previous layer
        # Here, we create dummy indices for demonstration purposes
        pool_output, indices = F.max_pool1d(x, kernel_size=2, stride=2, return_indices=True)
        x = self.max_unpool1d(pool_output, indices)
        
        # Reshape for TransformerEncoder
        x = x.permute(2, 0, 1)  # (sequence_length, batch_size, channels)
        x = self.transformer_encoder(x)
        x = x.permute(1, 2, 0)  # (batch_size, channels, sequence_length)
        
        # Apply FeatureAlphaDropout
        x = self.feature_alpha_dropout(x)
        
        # Reshape for Bilinear layer
        x = x.permute(0, 2, 1)  # (batch_size, sequence_length, channels)
        x = self.bilinear(x, x)  # Apply Bilinear transformation
        
        # Reshape back to original shape (batch_size, channels, sequence_length)
        x = x.permute(0, 2, 1)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 64, 128).cuda()  # (batch_size, channels, sequence_length)
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


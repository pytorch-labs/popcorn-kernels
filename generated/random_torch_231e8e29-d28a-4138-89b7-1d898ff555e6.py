
# This is a random torch model generated by the following modules: ['Hardtanh', 'RNNCell', 'PairwiseDistance', 'MaxPool3d', 'Transformer', 'Container', 'ModuleDict']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.hardtanh = nn.Hardtanh(min_val=-1.0, max_val=1.0)
        self.rnn_cell = nn.RNNCell(input_size=64, hidden_size=128)
        self.pairwise_distance = nn.PairwiseDistance(p=2)
        self.max_pool3d = nn.MaxPool3d(kernel_size=(2, 2, 2), stride=(2, 2, 2))
        self.transformer = nn.Transformer(d_model=64, nhead=8, num_encoder_layers=3, num_decoder_layers=3)
        self.container = nn.Sequential(
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, 32)
        )
        self.module_dict = nn.ModuleDict({
            'linear1': nn.Linear(32, 16),
            'linear2': nn.Linear(16, 8)
        })

    def forward(self, x):
        # Apply Hardtanh
        x = self.hardtanh(x)
        
        # Reshape for RNNCell
        batch_size = x.size(0)
        x = x.view(batch_size, -1, 64)  # Assuming input has at least 64 features
        hx = torch.zeros(batch_size, 128).to(x.device)
        for i in range(x.size(1)):
            hx = self.rnn_cell(x[:, i, :], hx)
        
        # PairwiseDistance
        x1 = hx[:, :64]
        x2 = hx[:, 64:]
        x = self.pairwise_distance(x1, x2)
        
        # Reshape for MaxPool3d
        x = x.view(batch_size, 1, 8, 8, 8)  # Arbitrary reshape to fit MaxPool3d
        x = self.max_pool3d(x)
        
        # Reshape for Transformer
        x = x.view(batch_size, -1, 64)  # Reshape to fit Transformer input
        x = self.transformer(x, x)  # Using the same tensor for src and tgt
        
        # Apply Container
        x = x.view(batch_size, -1)
        x = self.container(x)
        
        # Apply ModuleDict
        x = self.module_dict['linear1'](x)
        x = self.module_dict['linear2'](x)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 1, 64, 64).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

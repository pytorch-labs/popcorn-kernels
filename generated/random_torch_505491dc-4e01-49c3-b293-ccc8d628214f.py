
# This is a random torch model generated by the following modules: ['TripletMarginWithDistanceLoss', 'KLDivLoss', 'MaxPool3d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.maxpool3d = nn.MaxPool3d(kernel_size=2, stride=2)
        self.triplet_loss = nn.TripletMarginWithDistanceLoss(distance_function=lambda x, y: F.pairwise_distance(x, y, p=2))
        self.kldiv_loss = nn.KLDivLoss(reduction='batchmean')

    def forward(self, x):
        # Apply MaxPool3d to the input
        x = self.maxpool3d(x)
        
        # Generate anchor, positive, and negative samples for TripletMarginWithDistanceLoss
        anchor = x[:, :, 0, 0, 0].unsqueeze(2).unsqueeze(3).unsqueeze(4)  # Extract a single point as anchor
        positive = x[:, :, 1, 1, 1].unsqueeze(2).unsqueeze(3).unsqueeze(4)  # Extract another point as positive
        negative = x[:, :, 2, 2, 2].unsqueeze(2).unsqueeze(3).unsqueeze(4)  # Extract another point as negative
        
        # Compute TripletMarginWithDistanceLoss
        triplet_loss = self.triplet_loss(anchor, positive, negative)
        
        # Reshape x for KLDivLoss
        x_reshaped = x.view(x.size(0), -1)  # Flatten the tensor
        target = torch.softmax(torch.randn_like(x_reshaped), dim=1)  # Generate a random target distribution
        
        # Compute KLDivLoss
        kldiv_loss = self.kldiv_loss(F.log_softmax(x_reshaped, dim=1), target)
        
        # Return both losses as a tuple
        return triplet_loss, kldiv_loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 16, 16, 16).cuda()  # Example input with shape (batch_size, channels, depth, height, width)
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

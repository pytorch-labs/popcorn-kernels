
# This is a random torch model generated by the following modules: ['AdaptiveMaxPool3d', 'BCELoss', 'CosineEmbeddingLoss', 'PoissonNLLLoss']
import torch
import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.adaptive_max_pool3d = nn.AdaptiveMaxPool3d((5, 5, 5))
        self.bce_loss = nn.BCELoss()
        self.cosine_embedding_loss = nn.CosineEmbeddingLoss()
        self.poisson_nll_loss = nn.PoissonNLLLoss()

    def forward(self, x):
        # Apply AdaptiveMaxPool3d to the input
        x = self.adaptive_max_pool3d(x)
        
        # Flatten the output for further processing
        x = x.view(x.size(0), -1)
        
        # Generate random targets for loss functions
        target_bce = torch.randint(0, 2, (x.size(0), x.size(1)), dtype=torch.float32, device=x.device)
        target_cosine = torch.randint(0, 2, (x.size(0),), dtype=torch.float32, device=x.device)
        target_poisson = torch.randint(0, 10, (x.size(0), x.size(1)), dtype=torch.float32, device=x.device)
        
        # Apply BCELoss
        bce_loss = self.bce_loss(torch.sigmoid(x), target_bce)
        
        # Apply CosineEmbeddingLoss
        cosine_loss = self.cosine_embedding_loss(x, x, target_cosine)
        
        # Apply PoissonNLLLoss
        poisson_loss = self.poisson_nll_loss(x, target_poisson)
        
        # Return the sum of losses as the output
        return bce_loss + cosine_loss + poisson_loss

def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 10, 20, 20, 20).cuda()  # Example input shape for AdaptiveMaxPool3d
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []



# This is a random torch model generated by the following modules: ['LeakyReLU', 'ChannelShuffle', 'LazyInstanceNorm2d', 'InstanceNorm3d', 'ConvTranspose2d', 'AvgPool1d', 'TripletMarginWithDistanceLoss']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.leaky_relu = nn.LeakyReLU(negative_slope=0.1)
        self.channel_shuffle = nn.ChannelShuffle(groups=2)
        self.lazy_instance_norm_2d = nn.LazyInstanceNorm2d()
        self.instance_norm_3d = nn.InstanceNorm3d(num_features=16)
        self.conv_transpose_2d = nn.ConvTranspose2d(in_channels=16, out_channels=8, kernel_size=3, stride=2, padding=1)
        self.avg_pool_1d = nn.AvgPool1d(kernel_size=2, stride=2)
        self.triplet_loss = nn.TripletMarginWithDistanceLoss(distance_function=lambda x, y: F.pairwise_distance(x, y, p=2))

    def forward(self, x):
        # Assuming input x is of shape (batch_size, channels, height, width)
        x = self.leaky_relu(x)
        x = self.channel_shuffle(x)
        x = self.lazy_instance_norm_2d(x)
        
        # Reshape to 3D for InstanceNorm3d
        x = x.unsqueeze(2)  # Add a depth dimension
        x = self.instance_norm_3d(x)
        x = x.squeeze(2)  # Remove the depth dimension
        
        x = self.conv_transpose_2d(x)
        
        # Reshape for AvgPool1d
        x = x.view(x.size(0), x.size(1), -1)  # Flatten height and width
        x = self.avg_pool_1d(x)
        
        # Reshape back to 2D for triplet loss
        x = x.view(x.size(0), x.size(1), 1, -1)  # Reshape to (batch_size, channels, 1, features)
        
        # For triplet loss, we need three inputs: anchor, positive, negative
        anchor = x
        positive = x + torch.randn_like(x) * 0.1  # Simulate a positive sample
        negative = x + torch.randn_like(x) * 0.2  # Simulate a negative sample
        
        loss = self.triplet_loss(anchor, positive, negative)
        
        return loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 16, 32, 32).cuda()  # Example input shape
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


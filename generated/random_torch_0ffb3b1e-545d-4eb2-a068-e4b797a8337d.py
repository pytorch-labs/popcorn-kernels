
# This is a random torch model generated by the following modules: ['Upsample', 'AdaptiveAvgPool1d', 'TransformerEncoder', 'ConstantPad2d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.upsample = nn.Upsample(scale_factor=2, mode='nearest')
        self.adaptive_avg_pool1d = nn.AdaptiveAvgPool1d(output_size=128)
        self.transformer_encoder = nn.TransformerEncoder(
            nn.TransformerEncoderLayer(d_model=128, nhead=8), num_layers=3
        )
        self.constant_pad2d = nn.ConstantPad2d(padding=1, value=0)

    def forward(self, x):
        # Assume input is of arbitrary shape, reshape to 4D tensor if necessary
        if x.dim() == 2:
            x = x.unsqueeze(0).unsqueeze(0)  # Add batch and channel dimensions
        elif x.dim() == 3:
            x = x.unsqueeze(1)  # Add channel dimension

        # Apply ConstantPad2d
        x = self.constant_pad2d(x)

        # Apply Upsample
        x = self.upsample(x)

        # Reshape for AdaptiveAvgPool1d
        x = x.view(x.size(0), x.size(1), -1)  # Flatten spatial dimensions
        x = self.adaptive_avg_pool1d(x)

        # Reshape for TransformerEncoder
        x = x.permute(2, 0, 1)  # Transformer expects (seq_len, batch_size, d_model)
        x = self.transformer_encoder(x)

        # Reshape back to original format
        x = x.permute(1, 2, 0)  # (batch_size, d_model, seq_len)
        x = x.view(x.size(0), -1)  # Flatten for output

        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 32, 32).cuda()  # Example input with batch size 1, 3 channels, 32x32 spatial dimensions
    return [x]


def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


# Example usage
if __name__ == "__main__":
    model = Model().cuda()
    inputs = get_inputs()
    output = model(*inputs)
    print(output.shape)


# This is a random torch model generated by the following modules: ['Dropout2d', 'Softplus', 'AdaptiveMaxPool1d', 'Conv1d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.conv1 = nn.Conv1d(1, 10, kernel_size=5)
        self.dropout2d = nn.Dropout2d(p=0.5)
        self.adaptive_max_pool1d = nn.AdaptiveMaxPool1d(output_size=10)
        self.conv2 = nn.Conv1d(10, 20, kernel_size=5)
        self.softplus = nn.Softplus()

    def forward(self, x):
        # Assuming input is of shape (batch_size, channels, sequence_length)
        x = self.conv1(x)  # Shape: (batch_size, 10, sequence_length - 4)
        x = x.unsqueeze(2)  # Shape: (batch_size, 10, 1, sequence_length - 4)
        x = self.dropout2d(x)  # Shape: (batch_size, 10, 1, sequence_length - 4)
        x = x.squeeze(2)  # Shape: (batch_size, 10, sequence_length - 4)
        x = self.adaptive_max_pool1d(x)  # Shape: (batch_size, 10, 10)
        x = self.conv2(x)  # Shape: (batch_size, 20, 6)
        x = self.softplus(x)  # Shape: (batch_size, 20, 6)
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 1, 64).cuda()  # Example input shape: (batch_size, channels, sequence_length)
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


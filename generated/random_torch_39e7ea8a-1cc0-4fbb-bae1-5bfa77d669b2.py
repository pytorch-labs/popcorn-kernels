
# This is a random torch model generated by the following modules: ['Flatten', 'AvgPool3d', 'BCELoss', 'MultiMarginLoss', 'ReLU', 'Dropout', 'Linear']
import torch
import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.avgpool = nn.AvgPool3d(kernel_size=2, stride=2)
        self.flatten = nn.Flatten()
        self.dropout = nn.Dropout(p=0.5)
        self.relu = nn.ReLU()
        self.fc1 = nn.Linear(128, 64)
        self.fc2 = nn.Linear(64, 32)
        self.fc3 = nn.Linear(32, 1)
        self.bce_loss = nn.BCELoss()
        self.multi_margin_loss = nn.MultiMarginLoss()

    def forward(self, x):
        # Apply AvgPool3d
        x = self.avgpool(x)
        
        # Flatten the tensor
        x = self.flatten(x)
        
        # Apply Dropout
        x = self.dropout(x)
        
        # Apply ReLU activation
        x = self.relu(x)
        
        # First Linear layer
        x = self.fc1(x)
        
        # Apply ReLU activation
        x = self.relu(x)
        
        # Second Linear layer
        x = self.fc2(x)
        
        # Apply ReLU activation
        x = self.relu(x)
        
        # Third Linear layer
        x = self.fc3(x)
        
        # Apply Sigmoid to get output in range [0, 1] for BCELoss
        x = torch.sigmoid(x)
        
        # Dummy target for BCELoss (assuming binary classification)
        target = torch.randint(0, 2, (x.size(0), 1), dtype=torch.float32, device=x.device)
        
        # Compute BCELoss
        bce_loss = self.bce_loss(x, target)
        
        # Dummy target for MultiMarginLoss (assuming multi-class classification)
        target_multi = torch.randint(0, 10, (x.size(0),), dtype=torch.long, device=x.device)
        
        # Compute MultiMarginLoss
        multi_margin_loss = self.multi_margin_loss(x, target_multi)
        
        # Return both losses (for demonstration purposes)
        return bce_loss, multi_margin_loss

def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 32, 32, 32).cuda()  # Example input for 3D data
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

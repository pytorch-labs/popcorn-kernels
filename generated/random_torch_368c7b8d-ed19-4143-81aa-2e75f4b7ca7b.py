
# This is a random torch model generated by the following modules: ['Embedding', 'LPPool1d', 'GroupNorm', 'MaxPool3d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.embedding = nn.Embedding(1000, 128)  # Embedding layer
        self.lppool1d = nn.LPPool1d(norm_type=2, kernel_size=3, stride=2)  # LPPool1d layer
        self.groupnorm = nn.GroupNorm(num_groups=8, num_channels=128)  # GroupNorm layer
        self.maxpool3d = nn.MaxPool3d(kernel_size=2, stride=2)  # MaxPool3d layer

    def forward(self, x):
        # Assume input is a 1D tensor of indices for embedding
        x = self.embedding(x)  # (batch_size, seq_len) -> (batch_size, seq_len, embedding_dim)
        
        # Reshape for LPPool1d: (batch_size, seq_len, embedding_dim) -> (batch_size, embedding_dim, seq_len)
        x = x.permute(0, 2, 1)
        x = self.lppool1d(x)  # (batch_size, embedding_dim, seq_len) -> (batch_size, embedding_dim, pooled_seq_len)
        
        # Reshape for GroupNorm: (batch_size, embedding_dim, pooled_seq_len) -> (batch_size, embedding_dim, pooled_seq_len, 1)
        x = x.unsqueeze(-1)
        
        # Reshape for MaxPool3d: (batch_size, embedding_dim, pooled_seq_len, 1) -> (batch_size, 1, embedding_dim, pooled_seq_len, 1)
        x = x.unsqueeze(1)
        x = self.maxpool3d(x)  # (batch_size, 1, embedding_dim, pooled_seq_len, 1) -> (batch_size, 1, embedding_dim, pooled_seq_len//2, 1)
        
        # Reshape back to 2D: (batch_size, 1, embedding_dim, pooled_seq_len//2, 1) -> (batch_size, embedding_dim, pooled_seq_len//2)
        x = x.squeeze(1).squeeze(-1)
        
        # Apply GroupNorm
        x = self.groupnorm(x)  # (batch_size, embedding_dim, pooled_seq_len//2)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randint(0, 1000, (32, 50)).cuda()  # (batch_size, seq_len)
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


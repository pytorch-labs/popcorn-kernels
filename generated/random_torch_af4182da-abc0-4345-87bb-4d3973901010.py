
# This is a random torch model generated by the following modules: ['Identity', 'InstanceNorm3d', 'GLU', 'RMSNorm', 'Bilinear', 'FractionalMaxPool2d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.identity = nn.Identity()
        self.instance_norm3d = nn.InstanceNorm3d(10)
        self.glu = nn.GLU(dim=1)
        self.rms_norm = RMSNorm(20)  # Assuming RMSNorm is a custom module
        self.bilinear = nn.Bilinear(20, 20, 10)
        self.fractional_max_pool2d = nn.FractionalMaxPool2d(kernel_size=2, output_size=(14, 14))

    def forward(self, x):
        # Apply Identity
        x = self.identity(x)
        
        # Reshape for InstanceNorm3d (assuming input is 4D, we add a dummy dimension)
        x = x.unsqueeze(1)  # Add channel dimension
        x = x.unsqueeze(4)  # Add depth dimension
        x = self.instance_norm3d(x)
        
        # Reshape back to 4D
        x = x.squeeze(4)
        x = x.squeeze(1)
        
        # Apply GLU
        x = self.glu(x)
        
        # Apply RMSNorm
        x = self.rms_norm(x)
        
        # Apply FractionalMaxPool2d
        x = self.fractional_max_pool2d(x)
        
        # Reshape for Bilinear
        x = x.view(x.size(0), -1)  # Flatten
        x = self.bilinear(x, x)  # Use the same tensor for both inputs
        
        return x


class RMSNorm(nn.Module):
    def __init__(self, dim, eps=1e-8):
        super().__init__()
        self.scale = dim ** -0.5
        self.eps = eps
        self.g = nn.Parameter(torch.ones(dim))

    def forward(self, x):
        norm = torch.norm(x, dim=1, keepdim=True) * self.scale
        return x / norm.clamp(min=self.eps) * self.g


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 20, 28, 28).cuda()  # Arbitrary shape, adjusted for the model
    return [x]


def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

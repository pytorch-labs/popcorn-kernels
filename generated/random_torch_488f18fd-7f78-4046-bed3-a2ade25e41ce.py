
# This is a random torch model generated by the following modules: ['ConstantPad2d', 'RNNCell', 'Bilinear']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.pad = nn.ConstantPad2d(2, 3.0)  # Padding with value 3.0
        self.rnn_cell1 = nn.RNNCell(10, 20)  # Input size 10, hidden size 20
        self.rnn_cell2 = nn.RNNCell(20, 30)  # Input size 20, hidden size 30
        self.bilinear = nn.Bilinear(30, 40, 50)  # Input1 size 30, Input2 size 40, output size 50

    def forward(self, x):
        # Apply padding to the input
        x = self.pad(x)
        
        # Reshape the input to fit the RNNCell input size
        x = x.view(-1, 10)  # Reshape to (batch_size, 10)
        
        # Initialize hidden states for RNNCell
        h1 = torch.zeros(x.size(0), 20)  # Hidden state for rnn_cell1
        h2 = torch.zeros(x.size(0), 30)  # Hidden state for rnn_cell2
        
        # Apply RNNCell layers
        h1 = self.rnn_cell1(x, h1)
        h2 = self.rnn_cell2(h1, h2)
        
        # Create a second input for the Bilinear layer
        x2 = torch.randn(x.size(0), 40)  # Random input of size (batch_size, 40)
        
        # Apply Bilinear layer
        x = self.bilinear(h2, x2)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 64, 64).cuda()  # Arbitrary input shape
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


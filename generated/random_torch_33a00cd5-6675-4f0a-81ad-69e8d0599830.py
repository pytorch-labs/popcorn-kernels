
# This is a random torch model generated by the following modules: ['FractionalMaxPool2d', 'LSTMCell', 'Flatten', 'RNNBase', 'TripletMarginLoss', 'Dropout', 'PairwiseDistance', 'PixelShuffle', 'CircularPad1d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.fractional_max_pool = nn.FractionalMaxPool2d(kernel_size=2, output_size=(14, 14))
        self.lstm_cell = nn.LSTMCell(input_size=14*14, hidden_size=128)
        self.flatten = nn.Flatten()
        self.rnn = nn.RNN(input_size=128, hidden_size=64, num_layers=2, batch_first=True)
        self.dropout = nn.Dropout(p=0.5)
        self.pixel_shuffle = nn.PixelShuffle(upscale_factor=2)
        self.circular_pad = nn.CircularPad1d(padding=1)
        self.pairwise_distance = nn.PairwiseDistance(p=2)
        self.triplet_margin_loss = nn.TripletMarginLoss(margin=1.0, p=2)

    def forward(self, x):
        # Apply FractionalMaxPool2d
        x = self.fractional_max_pool(x)
        
        # Flatten the output for LSTMCell
        x = self.flatten(x)
        
        # Initialize hidden and cell states for LSTMCell
        hx = torch.zeros(x.size(0), 128).to(x.device)
        cx = torch.zeros(x.size(0), 128).to(x.device)
        
        # Apply LSTMCell
        hx, cx = self.lstm_cell(x, (hx, cx))
        
        # Reshape for RNN
        x = hx.unsqueeze(1)
        
        # Apply RNN
        x, _ = self.rnn(x)
        
        # Apply Dropout
        x = self.dropout(x)
        
        # Reshape for PixelShuffle
        x = x.permute(0, 2, 1)
        x = x.unsqueeze(1)
        x = self.pixel_shuffle(x)
        
        # Apply CircularPad1d
        x = x.squeeze(1)
        x = self.circular_pad(x)
        
        # Compute PairwiseDistance
        anchor = x[:, 0, :]
        positive = x[:, 1, :]
        negative = x[:, 2, :]
        distance_positive = self.pairwise_distance(anchor, positive)
        distance_negative = self.pairwise_distance(anchor, negative)
        
        # Compute TripletMarginLoss
        loss = self.triplet_margin_loss(anchor, positive, negative)
        
        return loss, distance_positive, distance_negative


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 28, 28).cuda()  # Example input shape
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


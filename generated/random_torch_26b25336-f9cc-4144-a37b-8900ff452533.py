
# This is a random torch model generated by the following modules: ['ModuleList', 'TransformerDecoderLayer', 'PairwiseDistance', 'Softmax', 'ZeroPad1d', 'CELU', 'AlphaDropout', 'ParameterDict', 'PixelShuffle']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        # Define a ModuleList containing multiple TransformerDecoderLayer instances
        self.transformer_layers = nn.ModuleList([
            nn.TransformerDecoderLayer(d_model=64, nhead=8) for _ in range(3)
        ])
        
        # Define a PairwiseDistance module
        self.pairwise_distance = nn.PairwiseDistance(p=2)
        
        # Define a Softmax module
        self.softmax = nn.Softmax(dim=1)
        
        # Define a ZeroPad1d module
        self.zero_pad = nn.ZeroPad1d(2)
        
        # Define a CELU activation function
        self.celu = nn.CELU()
        
        # Define an AlphaDropout module
        self.alpha_dropout = nn.AlphaDropout(p=0.5)
        
        # Define a ParameterDict to store learnable parameters
        self.param_dict = nn.ParameterDict({
            'weight': nn.Parameter(torch.randn(64, 64)),
            'bias': nn.Parameter(torch.randn(64))
        })
        
        # Define a PixelShuffle module
        self.pixel_shuffle = nn.PixelShuffle(2)

    def forward(self, x):
        # Apply ZeroPad1d to the input
        x = self.zero_pad(x)
        
        # Reshape the input to match the expected shape for TransformerDecoderLayer
        x = x.view(-1, 64, 64)
        
        # Pass the input through the TransformerDecoderLayer instances
        for layer in self.transformer_layers:
            x = layer(x, x)
        
        # Apply CELU activation
        x = self.celu(x)
        
        # Apply AlphaDropout
        x = self.alpha_dropout(x)
        
        # Reshape the tensor for PixelShuffle
        x = x.view(-1, 64, 8, 8)
        
        # Apply PixelShuffle
        x = self.pixel_shuffle(x)
        
        # Reshape the tensor for PairwiseDistance
        x = x.view(-1, 64)
        
        # Compute pairwise distance
        x = self.pairwise_distance(x, x)
        
        # Apply Softmax
        x = self.softmax(x)
        
        # Multiply by learnable parameters from ParameterDict
        x = torch.matmul(x, self.param_dict['weight']) + self.param_dict['bias']
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 64, 64).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

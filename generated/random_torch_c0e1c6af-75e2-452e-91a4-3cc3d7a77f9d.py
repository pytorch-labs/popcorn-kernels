
# This is a random torch model generated by the following modules: ['Hardsigmoid', 'CircularPad3d', 'RNNCell', 'AdaptiveMaxPool3d', 'InstanceNorm1d', 'LazyInstanceNorm3d', 'Flatten', 'LazyConvTranspose1d', 'ConstantPad3d', 'AdaptiveAvgPool3d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.circular_pad3d = nn.CircularPad3d(1)
        self.constant_pad3d = nn.ConstantPad3d(1, 0.5)
        self.lazy_conv_transpose1d = nn.LazyConvTranspose1d(out_channels=32, kernel_size=3)
        self.rnn_cell = nn.RNNCell(input_size=32, hidden_size=64)
        self.instance_norm1d = nn.InstanceNorm1d(num_features=64)
        self.lazy_instance_norm3d = nn.LazyInstanceNorm3d()
        self.adaptive_max_pool3d = nn.AdaptiveMaxPool3d(output_size=(8, 8, 8))
        self.adaptive_avg_pool3d = nn.AdaptiveAvgPool3d(output_size=(4, 4, 4))
        self.flatten = nn.Flatten()
        self.hardsigmoid = nn.Hardsigmoid()

    def forward(self, x):
        # Apply padding
        x = self.circular_pad3d(x)
        x = self.constant_pad3d(x)
        
        # Reshape for 1D convolution
        x = x.view(x.size(0), -1, x.size(-1))
        
        # Apply 1D convolution
        x = self.lazy_conv_transpose1d(x)
        
        # Reshape for RNN
        x = x.view(x.size(0), -1, x.size(-1))
        
        # Apply RNN
        hx = torch.zeros(x.size(0), 64).to(x.device)
        x = self.rnn_cell(x[:, 0, :], hx)
        
        # Apply instance normalization
        x = self.instance_norm1d(x)
        
        # Reshape for 3D operations
        x = x.view(x.size(0), 1, 8, 8, 8)
        
        # Apply 3D instance normalization
        x = self.lazy_instance_norm3d(x)
        
        # Apply adaptive pooling
        x = self.adaptive_max_pool3d(x)
        x = self.adaptive_avg_pool3d(x)
        
        # Flatten the output
        x = self.flatten(x)
        
        # Apply Hardsigmoid activation
        x = self.hardsigmoid(x)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 16, 16, 16).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []



# This is a random torch model generated by the following modules: ['LocalResponseNorm', 'ConstantPad2d', 'KLDivLoss', 'CrossEntropyLoss', 'CosineEmbeddingLoss', 'CrossMapLRN2d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.local_response_norm = nn.LocalResponseNorm(size=5)
        self.constant_pad = nn.ConstantPad2d(padding=2, value=1.0)
        self.cross_map_lrn = nn.CrossMapLRN2d(size=5)
        self.kl_div_loss = nn.KLDivLoss(reduction='batchmean')
        self.cross_entropy_loss = nn.CrossEntropyLoss()
        self.cosine_embedding_loss = nn.CosineEmbeddingLoss()

    def forward(self, x, target=None):
        # Apply LocalResponseNorm
        x = self.local_response_norm(x)
        
        # Apply ConstantPad2d
        x = self.constant_pad(x)
        
        # Apply CrossMapLRN2d
        x = self.cross_map_lrn(x)
        
        # Reshape for KLDivLoss
        x_reshaped = x.view(x.size(0), -1)
        log_softmax_x = F.log_softmax(x_reshaped, dim=1)
        
        # Compute KLDivLoss if target is provided
        if target is not None:
            kl_loss = self.kl_div_loss(log_softmax_x, target)
        else:
            kl_loss = torch.tensor(0.0)
        
        # Compute CrossEntropyLoss if target is provided
        if target is not None:
            cross_entropy_loss = self.cross_entropy_loss(log_softmax_x, target.argmax(dim=1))
        else:
            cross_entropy_loss = torch.tensor(0.0)
        
        # Compute CosineEmbeddingLoss if target is provided
        if target is not None:
            cosine_embedding_loss = self.cosine_embedding_loss(log_softmax_x, target, torch.ones(x.size(0)))
        else:
            cosine_embedding_loss = torch.tensor(0.0)
        
        # Return the losses as a dictionary
        return {
            'kl_div_loss': kl_loss,
            'cross_entropy_loss': cross_entropy_loss,
            'cosine_embedding_loss': cosine_embedding_loss
        }


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 32, 32).cuda()
    target = torch.randn(1, 3 * 32 * 32).cuda()
    return [x, target]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

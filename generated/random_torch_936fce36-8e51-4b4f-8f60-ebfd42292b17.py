
# This is a random torch model generated by the following modules: ['Upsample', 'ChannelShuffle', 'ZeroPad2d', 'RNNCell']
import torch
import torch.nn as nn


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.upsample1 = nn.Upsample(scale_factor=2, mode='nearest')
        self.channel_shuffle1 = nn.ChannelShuffle(groups=2)
        self.zero_pad2d1 = nn.ZeroPad2d(padding=1)
        self.rnn_cell1 = nn.RNNCell(input_size=64, hidden_size=128)
        self.rnn_cell2 = nn.RNNCell(input_size=128, hidden_size=64)
        self.upsample2 = nn.Upsample(scale_factor=2, mode='nearest')
        self.channel_shuffle2 = nn.ChannelShuffle(groups=4)
        self.zero_pad2d2 = nn.ZeroPad2d(padding=2)
        self.rnn_cell3 = nn.RNNCell(input_size=64, hidden_size=32)
        self.rnn_cell4 = nn.RNNCell(input_size=32, hidden_size=16)
        self.rnn_cell5 = nn.RNNCell(input_size=16, hidden_size=8)

    def forward(self, x):
        # Initial processing with Upsample, ChannelShuffle, and ZeroPad2d
        x = self.upsample1(x)
        x = self.channel_shuffle1(x)
        x = self.zero_pad2d1(x)
        
        # Reshape for RNNCell
        batch_size, channels, height, width = x.size()
        x = x.view(batch_size, -1)  # Flatten spatial dimensions
        
        # Process through RNNCells
        hx1 = torch.zeros(batch_size, 128).to(x.device)
        hx1 = self.rnn_cell1(x, hx1)
        
        hx2 = torch.zeros(batch_size, 64).to(x.device)
        hx2 = self.rnn_cell2(hx1, hx2)
        
        # Reshape back to 4D tensor for further processing
        x = hx2.view(batch_size, channels, height, width)
        
        # Additional processing with Upsample, ChannelShuffle, and ZeroPad2d
        x = self.upsample2(x)
        x = self.channel_shuffle2(x)
        x = self.zero_pad2d2(x)
        
        # Reshape for RNNCell
        batch_size, channels, height, width = x.size()
        x = x.view(batch_size, -1)  # Flatten spatial dimensions
        
        # Process through more RNNCells
        hx3 = torch.zeros(batch_size, 32).to(x.device)
        hx3 = self.rnn_cell3(x, hx3)
        
        hx4 = torch.zeros(batch_size, 16).to(x.device)
        hx4 = self.rnn_cell4(hx3, hx4)
        
        hx5 = torch.zeros(batch_size, 8).to(x.device)
        hx5 = self.rnn_cell5(hx4, hx5)
        
        return hx5


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 32, 32).cuda()  # Example input shape
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


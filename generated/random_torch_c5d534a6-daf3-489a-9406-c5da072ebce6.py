
# This is a random torch model generated by the following modules: ['ChannelShuffle', 'CircularPad3d', 'LazyBatchNorm2d', 'AdaptiveMaxPool1d', 'ConstantPad3d', 'Conv1d', 'LazyBatchNorm3d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.channel_shuffle = nn.ChannelShuffle(groups=2)
        self.circular_pad3d = nn.CircularPad3d(padding=(1, 1, 1, 1, 1, 1))
        self.lazy_bn2d = nn.LazyBatchNorm2d()
        self.adaptive_max_pool1d = nn.AdaptiveMaxPool1d(output_size=10)
        self.constant_pad3d = nn.ConstantPad3d(padding=(1, 1, 1, 1, 1, 1), value=0.5)
        self.conv1d = nn.Conv1d(in_channels=10, out_channels=20, kernel_size=3, stride=1)
        self.lazy_bn3d = nn.LazyBatchNorm3d()

    def forward(self, x):
        # Assuming input x is of shape (batch_size, channels, depth, height, width)
        x = self.circular_pad3d(x)  # Apply CircularPad3d
        x = self.constant_pad3d(x)  # Apply ConstantPad3d
        x = self.lazy_bn3d(x)  # Apply LazyBatchNorm3d
        
        # Reshape to 2D for LazyBatchNorm2d
        x = x.view(x.size(0), x.size(1), -1)  # Flatten depth and height
        x = self.lazy_bn2d(x)  # Apply LazyBatchNorm2d
        
        # Reshape back to 3D for Conv1d
        x = x.view(x.size(0), x.size(1), x.size(2), 1)  # Add a dummy dimension for Conv1d
        x = x.squeeze(-1)  # Remove the dummy dimension
        
        x = self.conv1d(x)  # Apply Conv1d
        x = self.adaptive_max_pool1d(x)  # Apply AdaptiveMaxPool1d
        
        # Reshape for ChannelShuffle
        x = x.unsqueeze(-1).unsqueeze(-1)  # Add dummy dimensions for ChannelShuffle
        x = self.channel_shuffle(x)  # Apply ChannelShuffle
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 10, 5, 5, 5).cuda()  # Example input shape (batch_size, channels, depth, height, width)
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


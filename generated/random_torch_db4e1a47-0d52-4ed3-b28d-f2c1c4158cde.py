
# This is a random torch model generated by the following modules: ['AdaptiveLogSoftmaxWithLoss', 'TransformerDecoder', 'PairwiseDistance', 'CircularPad3d', 'TransformerEncoderLayer']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.circular_pad = nn.CircularPad3d(1)
        self.transformer_encoder_layer = nn.TransformerEncoderLayer(d_model=64, nhead=8)
        self.transformer_decoder = nn.TransformerDecoder(
            nn.TransformerDecoderLayer(d_model=64, nhead=8), num_layers=3
        )
        self.pairwise_distance = nn.PairwiseDistance()
        self.adaptive_log_softmax = nn.AdaptiveLogSoftmaxWithLoss(
            in_features=64, n_classes=10, cutoffs=[2, 4]
        )

    def forward(self, x):
        # Apply CircularPad3d
        x = self.circular_pad(x)
        
        # Reshape for TransformerEncoderLayer
        x = x.view(-1, 64, 64)  # Assuming input is reshaped to (batch_size, seq_len, d_model)
        
        # Apply TransformerEncoderLayer
        x = self.transformer_encoder_layer(x)
        
        # Reshape for TransformerDecoder
        x = x.view(-1, 64, 64)  # Assuming input is reshaped to (batch_size, seq_len, d_model)
        
        # Apply TransformerDecoder
        memory = torch.randn_like(x)  # Random memory for TransformerDecoder
        x = self.transformer_decoder(x, memory)
        
        # Reshape for PairwiseDistance
        x = x.view(-1, 64)  # Assuming input is reshaped to (batch_size, d_model)
        y = torch.randn_like(x)  # Random tensor for PairwiseDistance
        x = self.pairwise_distance(x, y)
        
        # Reshape for AdaptiveLogSoftmaxWithLoss
        x = x.view(-1, 64)  # Assuming input is reshaped to (batch_size, d_model)
        target = torch.randint(0, 10, (x.size(0),))  # Random target for AdaptiveLogSoftmaxWithLoss
        x = self.adaptive_log_softmax(x, target)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 64, 64, 64).cuda()  # Arbitrary input shape
    return [x]


def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

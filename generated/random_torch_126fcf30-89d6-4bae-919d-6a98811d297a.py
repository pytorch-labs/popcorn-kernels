
# This is a random torch model generated by the following modules: ['MaxPool3d', 'Sequential', 'AvgPool1d', 'ZeroPad1d', 'LPPool3d', 'RNNCellBase']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.maxpool3d = nn.MaxPool3d(kernel_size=2, stride=2)
        self.sequential = nn.Sequential(
            nn.ZeroPad1d(2),
            nn.AvgPool1d(kernel_size=3, stride=1)
        )
        self.lppool3d = nn.LPPool3d(norm_type=2, kernel_size=2, stride=2)
        self.rnncell = nn.RNNCell(input_size=64, hidden_size=128)

    def forward(self, x):
        # Assuming input is 5D (batch, channels, depth, height, width)
        x = self.maxpool3d(x)
        
        # Reshape to 3D (batch * depth, channels, height * width)
        batch, channels, depth, height, width = x.shape
        x = x.view(batch * depth, channels, height * width)
        
        # Apply Sequential (ZeroPad1d and AvgPool1d)
        x = self.sequential(x)
        
        # Reshape back to 5D
        x = x.view(batch, depth, channels, -1)
        x = x.permute(0, 2, 1, 3).contiguous()
        
        # Apply LPPool3d
        x = self.lppool3d(x)
        
        # Reshape to 2D (batch, features) for RNNCell
        batch, channels, depth, height, width = x.shape
        x = x.view(batch, -1)
        
        # Initialize hidden state for RNNCell
        hx = torch.zeros(batch, 128).to(x.device)
        
        # Apply RNNCell
        x = self.rnncell(x, hx)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 32, 64, 64).cuda()  # Example input: (batch, channels, depth, height, width)
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []



# This is a random torch model generated by the following modules: ['AvgPool3d', 'GRUCell', 'ModuleDict', 'ZeroPad2d', 'ConvTranspose1d', 'LayerNorm', 'PoissonNLLLoss']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.avg_pool = nn.AvgPool3d(kernel_size=2, stride=2)
        self.gru_cell = nn.GRUCell(input_size=64, hidden_size=128)
        self.module_dict = nn.ModuleDict({
            'conv_transpose': nn.ConvTranspose1d(in_channels=128, out_channels=64, kernel_size=3, stride=1),
            'zero_pad': nn.ZeroPad2d(padding=1),
            'layer_norm': nn.LayerNorm(64)
        })
        self.poisson_loss = nn.PoissonNLLLoss()

    def forward(self, x):
        # Assuming input x is of shape (batch_size, channels, depth, height, width)
        x = self.avg_pool(x)  # Apply AvgPool3d
        x = x.view(x.size(0), -1)  # Flatten for GRUCell
        hx = torch.zeros(x.size(0), 128).to(x.device)  # Initialize hidden state for GRUCell
        x = self.gru_cell(x, hx)  # Apply GRUCell
        x = x.unsqueeze(2)  # Reshape for ConvTranspose1d
        x = self.module_dict['conv_transpose'](x)  # Apply ConvTranspose1d
        x = x.unsqueeze(2).unsqueeze(2)  # Reshape for ZeroPad2d
        x = self.module_dict['zero_pad'](x)  # Apply ZeroPad2d
        x = x.squeeze(2).squeeze(2)  # Reshape for LayerNorm
        x = self.module_dict['layer_norm'](x)  # Apply LayerNorm
        # Assuming target is a tensor of the same shape as x for PoissonNLLLoss
        target = torch.randn_like(x)
        loss = self.poisson_loss(x, target)  # Apply PoissonNLLLoss
        return loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 32, 32, 32).cuda()  # Example input shape
    return [x]


def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


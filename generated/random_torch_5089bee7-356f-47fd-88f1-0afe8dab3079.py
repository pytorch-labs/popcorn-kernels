
# This is a random torch model generated by the following modules: ['MaxPool1d', 'LayerNorm', 'ParameterList', 'PairwiseDistance', 'RNNCell', 'PReLU', 'Hardswish']
import torch
import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.maxpool1d = nn.MaxPool1d(kernel_size=2)
        self.layernorm = nn.LayerNorm(64)
        self.parameterlist = nn.ParameterList([nn.Parameter(torch.randn(64)) for _ in range(3)])
        self.pairwisedistance = nn.PairwiseDistance(p=2)
        self.rnncell = nn.RNNCell(input_size=64, hidden_size=64)
        self.prelu = nn.PReLU()
        self.hardswish = nn.Hardswish()

    def forward(self, x):
        # Assuming input x is of shape (batch_size, channels, sequence_length)
        x = self.maxpool1d(x)  # Shape: (batch_size, channels, sequence_length // 2)
        x = x.permute(0, 2, 1)  # Shape: (batch_size, sequence_length // 2, channels)
        x = self.layernorm(x)  # Shape: (batch_size, sequence_length // 2, channels)
        
        # Apply ParameterList
        for param in self.parameterlist:
            x = x + param  # Shape: (batch_size, sequence_length // 2, channels)
        
        # PairwiseDistance requires two inputs, so we split the tensor
        x1, x2 = x.chunk(2, dim=1)  # Shape: (batch_size, sequence_length // 4, channels)
        x = self.pairwisedistance(x1, x2)  # Shape: (batch_size, sequence_length // 4)
        x = x.unsqueeze(-1)  # Shape: (batch_size, sequence_length // 4, 1)
        
        # RNNCell requires input of shape (batch_size, input_size)
        x = x.squeeze(-1)  # Shape: (batch_size, sequence_length // 4)
        hx = torch.zeros(x.size(0), 64).to(x.device)  # Initialize hidden state
        x = self.rnncell(x, hx)  # Shape: (batch_size, hidden_size)
        
        x = self.prelu(x)  # Shape: (batch_size, hidden_size)
        x = self.hardswish(x)  # Shape: (batch_size, hidden_size)
        
        return x

def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 64, 128).cuda()  # Shape: (batch_size, channels, sequence_length)
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

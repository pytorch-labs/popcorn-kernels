
# This is a random torch model generated by the following modules: ['SoftMarginLoss', 'Softmax', 'CircularPad3d', 'AvgPool2d', 'Hardswish', 'LazyConv3d', 'HingeEmbeddingLoss', 'MultiMarginLoss']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.circular_pad = nn.CircularPad3d(1)
        self.lazy_conv3d = nn.LazyConv3d(out_channels=16, kernel_size=3)
        self.avg_pool2d = nn.AvgPool2d(kernel_size=2)
        self.hardswish = nn.Hardswish()
        self.softmax = nn.Softmax(dim=1)
        self.soft_margin_loss = nn.SoftMarginLoss()
        self.hinge_embedding_loss = nn.HingeEmbeddingLoss()
        self.multi_margin_loss = nn.MultiMarginLoss()

    def forward(self, x):
        # Apply CircularPad3d
        x = self.circular_pad(x)
        
        # Apply LazyConv3d
        x = self.lazy_conv3d(x)
        
        # Reshape to 2D for AvgPool2d
        x = x.view(x.size(0), x.size(1), -1, x.size(-1))
        
        # Apply AvgPool2d
        x = self.avg_pool2d(x)
        
        # Apply Hardswish
        x = self.hardswish(x)
        
        # Reshape back to original shape
        x = x.view(x.size(0), x.size(1), x.size(2), x.size(3), -1)
        
        # Apply Softmax
        x = self.softmax(x)
        
        # Dummy target for loss functions
        target = torch.randint(0, 2, (x.size(0),), device=x.device)
        
        # Apply SoftMarginLoss
        loss1 = self.soft_margin_loss(x.view(x.size(0), -1), target.float())
        
        # Apply HingeEmbeddingLoss
        loss2 = self.hinge_embedding_loss(x.view(x.size(0), -1), target.float())
        
        # Apply MultiMarginLoss
        loss3 = self.multi_margin_loss(x.view(x.size(0), -1), target)
        
        # Return the average of the losses
        return (loss1 + loss2 + loss3) / 3


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 32, 32, 32).cuda()  # Example input shape
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


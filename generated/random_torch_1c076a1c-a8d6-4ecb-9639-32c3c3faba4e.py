
# This is a random torch model generated by the following modules: ['ParameterList', 'CircularPad1d', 'AdaptiveMaxPool2d', 'NLLLoss']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        # Initialize ParameterList with some parameters
        self.params = nn.ParameterList([
            nn.Parameter(torch.randn(10)),
            nn.Parameter(torch.randn(10))
        ])
        # Initialize CircularPad1d with padding size 2
        self.circular_pad = nn.CircularPad1d(2)
        # Initialize AdaptiveMaxPool2d with output size (5, 5)
        self.adaptive_max_pool = nn.AdaptiveMaxPool2d((5, 5))
        # Initialize NLLLoss
        self.nll_loss = nn.NLLLoss()

    def forward(self, x):
        # Apply CircularPad1d to the input
        x = self.circular_pad(x)
        
        # Reshape the input to fit into AdaptiveMaxPool2d
        x = x.view(-1, 1, x.size(1), x.size(2))
        
        # Apply AdaptiveMaxPool2d
        x = self.adaptive_max_pool(x)
        
        # Flatten the output for ParameterList
        x = x.view(-1, x.size(1) * x.size(2) * x.size(3))
        
        # Apply the parameters from ParameterList
        for param in self.params:
            x = x + param.unsqueeze(0).expand_as(x)
        
        # Compute the log probabilities
        log_probs = F.log_softmax(x, dim=1)
        
        # Dummy target for NLLLoss (assuming classification with 10 classes)
        target = torch.randint(0, 10, (x.size(0),)).to(x.device)
        
        # Compute the loss using NLLLoss
        loss = self.nll_loss(log_probs, target)
        
        return loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 10, 10).cuda()  # Example input shape
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


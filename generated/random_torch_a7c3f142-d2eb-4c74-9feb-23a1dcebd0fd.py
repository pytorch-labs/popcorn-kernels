
# This is a random torch model generated by the following modules: ['CrossEntropyLoss', 'ConvTranspose3d', 'MaxUnpool3d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.conv_transpose1 = nn.ConvTranspose3d(1, 10, kernel_size=3, stride=2, padding=1)
        self.conv_transpose2 = nn.ConvTranspose3d(10, 20, kernel_size=3, stride=2, padding=1)
        self.max_unpool1 = nn.MaxUnpool3d(kernel_size=2, stride=2, padding=0)
        self.max_unpool2 = nn.MaxUnpool3d(kernel_size=2, stride=2, padding=0)
        self.criterion = nn.CrossEntropyLoss()

    def forward(self, x, target=None):
        # Assuming x is of shape (batch_size, channels, depth, height, width)
        x = F.relu(self.conv_transpose1(x))
        x, indices1 = F.max_pool3d(x, kernel_size=2, stride=2, return_indices=True)
        x = F.relu(self.conv_transpose2(x))
        x, indices2 = F.max_pool3d(x, kernel_size=2, stride=2, return_indices=True)
        
        # Unpooling
        x = self.max_unpool1(x, indices2)
        x = self.max_unpool2(x, indices1)
        
        # Flatten the output for CrossEntropyLoss
        x = x.view(x.size(0), -1)
        
        # If target is provided, compute the loss
        if target is not None:
            loss = self.criterion(x, target)
            return x, loss
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 1, 16, 16, 16).cuda()  # Example input shape
    target = torch.randint(0, 20, (1,)).cuda()  # Example target for CrossEntropyLoss
    return [x, target]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


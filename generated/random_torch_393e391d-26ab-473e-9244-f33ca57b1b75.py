
# This is a random torch model generated by the following modules: ['AvgPool1d', 'PixelShuffle', 'Softsign', 'PairwiseDistance', 'MSELoss', 'BCEWithLogitsLoss', 'LPPool3d', 'AdaptiveMaxPool1d', 'NLLLoss', 'Unfold']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.avgpool1d = nn.AvgPool1d(kernel_size=2)
        self.pixelshuffle = nn.PixelShuffle(upscale_factor=2)
        self.softsign = nn.Softsign()
        self.pairwisedistance = nn.PairwiseDistance(p=2)
        self.mseloss = nn.MSELoss()
        self.bcewithlogitsloss = nn.BCEWithLogitsLoss()
        self.lppool3d = nn.LPPool3d(norm_type=2, kernel_size=2, stride=2)
        self.adaptivemaxpool1d = nn.AdaptiveMaxPool1d(output_size=10)
        self.nllloss = nn.NLLLoss()
        self.unfold = nn.Unfold(kernel_size=(2, 2))

    def forward(self, x):
        # Apply AvgPool1d
        x = x.view(x.size(0), x.size(1), -1)  # Reshape to (batch_size, channels, length)
        x = self.avgpool1d(x)
        
        # Apply PixelShuffle
        x = x.view(x.size(0), x.size(1), 1, x.size(2))  # Reshape to (batch_size, channels, 1, length)
        x = self.pixelshuffle(x)
        
        # Apply Softsign
        x = self.softsign(x)
        
        # Apply PairwiseDistance
        x1 = x[:, :x.size(1)//2, :, :]
        x2 = x[:, x.size(1)//2:, :, :]
        x = self.pairwisedistance(x1.view(x1.size(0), -1), x2.view(x2.size(0), -1))
        
        # Apply LPPool3d
        x = x.view(x.size(0), 1, 1, 1, x.size(1))  # Reshape to (batch_size, 1, 1, 1, length)
        x = self.lppool3d(x)
        
        # Apply AdaptiveMaxPool1d
        x = x.view(x.size(0), x.size(1), -1)  # Reshape to (batch_size, channels, length)
        x = self.adaptivemaxpool1d(x)
        
        # Apply Unfold
        x = x.view(x.size(0), 1, x.size(1), x.size(2))  # Reshape to (batch_size, 1, channels, length)
        x = self.unfold(x)
        
        # Apply MSELoss (dummy target)
        target = torch.randn_like(x)
        x = self.mseloss(x, target)
        
        # Apply BCEWithLogitsLoss (dummy target)
        target = torch.randn_like(x)
        x = self.bcewithlogitsloss(x, target)
        
        # Apply NLLLoss (dummy target)
        x = x.view(x.size(0), -1)  # Reshape to (batch_size, features)
        target = torch.randint(0, x.size(1), (x.size(0),))
        x = self.nllloss(x, target)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 16, 64, 64).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

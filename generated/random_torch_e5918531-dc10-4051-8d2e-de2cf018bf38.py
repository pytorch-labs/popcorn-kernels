
# This is a random torch model generated by the following modules: ['RMSNorm', 'Unflatten', 'ReLU6']
import torch
import torch.nn as nn
import torch.nn.functional as F


class RMSNorm(nn.Module):
    def __init__(self, dim):
        super().__init__()
        self.scale = dim ** 0.5
        self.gamma = nn.Parameter(torch.ones(dim))

    def forward(self, x):
        return F.normalize(x, dim=-1) * self.gamma * self.scale


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.rms_norm1 = RMSNorm(64)
        self.unflatten1 = nn.Unflatten(1, (8, 8))
        self.relu6 = nn.ReLU6()
        self.rms_norm2 = RMSNorm(64)
        self.unflatten2 = nn.Unflatten(1, (8, 8))
        self.rms_norm3 = RMSNorm(64)

    def forward(self, x):
        # Flatten the input to apply RMSNorm
        original_shape = x.shape
        x = x.view(original_shape[0], -1)
        
        # Apply the first RMSNorm
        x = self.rms_norm1(x)
        
        # Reshape back to a 2D tensor for Unflatten
        x = x.view(original_shape[0], -1, 8, 8)
        
        # Apply the first Unflatten
        x = self.unflatten1(x)
        
        # Apply ReLU6
        x = self.relu6(x)
        
        # Flatten again for the second RMSNorm
        x = x.view(original_shape[0], -1)
        
        # Apply the second RMSNorm
        x = self.rms_norm2(x)
        
        # Reshape back to a 2D tensor for the second Unflatten
        x = x.view(original_shape[0], -1, 8, 8)
        
        # Apply the second Unflatten
        x = self.unflatten2(x)
        
        # Flatten again for the third RMSNorm
        x = x.view(original_shape[0], -1)
        
        # Apply the third RMSNorm
        x = self.rms_norm3(x)
        
        # Reshape back to the original shape
        x = x.view(original_shape)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 64, 64).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


# This is a random torch model generated by the following modules: ['Softmax2d', 'CrossEntropyLoss', 'ZeroPad2d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.zero_pad = nn.ZeroPad2d(2)  # Padding to ensure the input size is compatible with Softmax2d
        self.softmax = nn.Softmax2d()    # Softmax2d applied to the spatial dimensions
        self.loss = nn.CrossEntropyLoss()  # CrossEntropyLoss for computing the loss

    def forward(self, x, target=None):
        # Apply ZeroPad2d to the input
        x = self.zero_pad(x)
        
        # Apply Softmax2d to the padded input
        x = self.softmax(x)
        
        # If a target is provided, compute the CrossEntropyLoss
        if target is not None:
            # Reshape the target to match the output shape of Softmax2d
            target = target.view(-1, *x.shape[2:])
            loss = self.loss(x, target)
            return x, loss
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 64, 64).cuda()  # Example input with 3 channels and 64x64 spatial dimensions
    target = torch.randint(0, 3, (1, 64, 64)).cuda()  # Example target with the same spatial dimensions
    return [x, target]


def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


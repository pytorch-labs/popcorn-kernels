
# This is a random torch model generated by the following modules: ['GaussianNLLLoss', 'GLU', 'EmbeddingBag', 'PixelUnshuffle', 'RNN', 'BCELoss', 'CircularPad1d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.embedding_bag = nn.EmbeddingBag(1000, 64, mode='mean')
        self.glu = nn.GLU(dim=1)
        self.pixel_unshuffle = nn.PixelUnshuffle(2)
        self.rnn = nn.RNN(64, 128, batch_first=True)
        self.circular_pad1d = nn.CircularPad1d(2)
        self.gaussian_nll_loss = nn.GaussianNLLLoss()
        self.bce_loss = nn.BCELoss()

    def forward(self, x):
        # Assume x is a tensor of arbitrary shape
        # First, reshape x to be compatible with EmbeddingBag
        x = x.view(-1).long()  # Flatten and convert to long for embedding
        x = self.embedding_bag(x)
        
        # Reshape for GLU
        x = x.unsqueeze(1)  # Add a dimension for GLU
        x = self.glu(x)
        
        # Reshape for PixelUnshuffle
        x = x.unsqueeze(2).unsqueeze(3)  # Add dimensions for PixelUnshuffle
        x = self.pixel_unshuffle(x)
        
        # Reshape for RNN
        x = x.view(x.size(0), -1, 64)  # Reshape to (batch_size, seq_len, feature_size)
        x, _ = self.rnn(x)
        
        # Apply CircularPad1d
        x = x.permute(0, 2, 1)  # Swap dimensions for CircularPad1d
        x = self.circular_pad1d(x)
        x = x.permute(0, 2, 1)  # Swap back
        
        # Compute GaussianNLLLoss (requires target and variance)
        target = torch.randn_like(x)
        var = torch.ones_like(x)
        gaussian_loss = self.gaussian_nll_loss(x, target, var)
        
        # Compute BCELoss (requires sigmoid output and target)
        bce_target = torch.randint(0, 2, x.shape).float()
        bce_loss = self.bce_loss(torch.sigmoid(x), bce_target)
        
        # Return both losses for demonstration purposes
        return gaussian_loss, bce_loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randint(0, 1000, (10, 10)).cuda()  # Arbitrary shape for embedding
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


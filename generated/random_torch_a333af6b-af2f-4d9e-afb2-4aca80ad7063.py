
# This is a random torch model generated by the following modules: ['Softplus', 'MaxUnpool1d', 'Softmax2d', 'ConvTranspose2d', 'InstanceNorm3d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.softplus = nn.Softplus()
        self.max_unpool1d = nn.MaxUnpool1d(kernel_size=2, stride=2)
        self.softmax2d = nn.Softmax2d()
        self.conv_transpose2d = nn.ConvTranspose2d(3, 6, kernel_size=3, stride=2)
        self.instance_norm3d = nn.InstanceNorm3d(6)
        
        # Additional layers to accommodate the input and output shapes
        self.conv1 = nn.Conv2d(1, 3, kernel_size=3, stride=1, padding=1)
        self.conv2 = nn.Conv2d(6, 1, kernel_size=3, stride=1, padding=1)

    def forward(self, x):
        # Assuming input is 4D (batch, channels, height, width)
        x = self.conv1(x)  # Shape: (batch, 3, height, width)
        x = self.softplus(x)
        
        # Reshape for MaxUnpool1d
        x = x.view(x.size(0), x.size(1), -1)  # Shape: (batch, 3, height * width)
        indices = torch.arange(0, x.size(2), device=x.device).unsqueeze(0).unsqueeze(0).repeat(x.size(0), x.size(1), 1)
        x = self.max_unpool1d(x, indices)  # Shape: (batch, 3, 2 * height * width)
        
        # Reshape back to 4D
        x = x.view(x.size(0), x.size(1), x.size(2) // 2, 2)  # Shape: (batch, 3, height * width, 2)
        
        # Apply Softmax2d
        x = self.softmax2d(x)
        
        # Apply ConvTranspose2d
        x = self.conv_transpose2d(x)  # Shape: (batch, 6, height * 2, width * 2)
        
        # Reshape for InstanceNorm3d
        x = x.unsqueeze(2)  # Shape: (batch, 6, 1, height * 2, width * 2)
        x = self.instance_norm3d(x)  # Shape: (batch, 6, 1, height * 2, width * 2)
        
        # Reshape back to 4D
        x = x.squeeze(2)  # Shape: (batch, 6, height * 2, width * 2)
        
        # Final convolution to reduce channels
        x = self.conv2(x)  # Shape: (batch, 1, height * 2, width * 2)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 1, 32, 32).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


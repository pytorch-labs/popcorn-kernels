
# This is a random torch model generated by the following modules: ['LazyConv2d', 'ReplicationPad1d', 'UpsamplingBilinear2d', 'ChannelShuffle', 'ReLU', 'GELU', 'CircularPad1d', 'Dropout3d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.conv1 = nn.LazyConv2d(out_channels=16, kernel_size=3)
        self.pad1 = nn.ReplicationPad1d(padding=1)
        self.upsample1 = nn.UpsamplingBilinear2d(scale_factor=2)
        self.shuffle1 = nn.ChannelShuffle(groups=4)
        self.relu1 = nn.ReLU()
        self.gelu1 = nn.GELU()
        self.circular_pad1 = nn.CircularPad1d(padding=1)
        self.dropout1 = nn.Dropout3d(p=0.5)
        self.conv2 = nn.LazyConv2d(out_channels=32, kernel_size=3)
        self.pad2 = nn.ReplicationPad1d(padding=1)
        self.upsample2 = nn.UpsamplingBilinear2d(scale_factor=2)
        self.shuffle2 = nn.ChannelShuffle(groups=8)
        self.relu2 = nn.ReLU()
        self.gelu2 = nn.GELU()
        self.circular_pad2 = nn.CircularPad1d(padding=1)
        self.dropout2 = nn.Dropout3d(p=0.5)

    def forward(self, x):
        # Initial processing
        x = self.conv1(x)
        x = self.pad1(x.view(x.size(0), x.size(1), -1)).view(x.size(0), x.size(1), x.size(2), x.size(3))
        x = self.upsample1(x)
        x = self.shuffle1(x)
        x = self.relu1(x)
        x = self.gelu1(x)
        x = self.circular_pad1(x.view(x.size(0), x.size(1), -1)).view(x.size(0), x.size(1), x.size(2), x.size(3))
        x = self.dropout1(x)
        
        # Further processing
        x = self.conv2(x)
        x = self.pad2(x.view(x.size(0), x.size(1), -1)).view(x.size(0), x.size(1), x.size(2), x.size(3))
        x = self.upsample2(x)
        x = self.shuffle2(x)
        x = self.relu2(x)
        x = self.gelu2(x)
        x = self.circular_pad2(x.view(x.size(0), x.size(1), -1)).view(x.size(0), x.size(1), x.size(2), x.size(3))
        x = self.dropout2(x)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 64, 64).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

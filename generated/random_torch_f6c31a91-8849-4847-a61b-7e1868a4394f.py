
# This is a random torch model generated by the following modules: ['Softmax2d', 'GRU', 'BCELoss', 'Module', 'Flatten', 'LazyConvTranspose3d', 'TripletMarginLoss', 'PixelShuffle', 'HingeEmbeddingLoss']
import torch
import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.conv_transpose = nn.LazyConvTranspose3d(out_channels=16, kernel_size=3, stride=2, padding=1)
        self.pixel_shuffle = nn.PixelShuffle(2)
        self.flatten = nn.Flatten()
        self.gru = nn.GRU(input_size=128, hidden_size=64, num_layers=2, batch_first=True)
        self.softmax = nn.Softmax2d()
        self.bce_loss = nn.BCELoss()
        self.triplet_loss = nn.TripletMarginLoss()
        self.hinge_loss = nn.HingeEmbeddingLoss()

    def forward(self, x):
        # Apply ConvTranspose3d
        x = self.conv_transpose(x)
        
        # Reshape for PixelShuffle
        x = x.view(x.size(0), x.size(1), -1, x.size(3), x.size(4))
        x = self.pixel_shuffle(x)
        
        # Flatten the output
        x = self.flatten(x)
        
        # Reshape for GRU
        x = x.view(x.size(0), -1, 128)
        x, _ = self.gru(x)
        
        # Apply Softmax2d
        x = x.view(x.size(0), x.size(1), 1, 1)
        x = self.softmax(x)
        
        # Compute BCE Loss (dummy target)
        target = torch.zeros_like(x)
        bce_loss = self.bce_loss(x, target)
        
        # Compute Triplet Margin Loss (dummy anchors, positives, negatives)
        anchor = torch.randn_like(x)
        positive = torch.randn_like(x)
        negative = torch.randn_like(x)
        triplet_loss = self.triplet_loss(anchor, positive, negative)
        
        # Compute Hinge Embedding Loss (dummy target)
        hinge_target = torch.ones_like(x).sign()
        hinge_loss = self.hinge_loss(x, hinge_target)
        
        # Return the losses as a tuple
        return bce_loss, triplet_loss, hinge_loss

def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 32, 32, 32).cuda()  # Arbitrary input shape
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

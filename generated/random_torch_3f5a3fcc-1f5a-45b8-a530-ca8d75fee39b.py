
# This is a random torch model generated by the following modules: ['PReLU', 'MaxUnpool2d', 'ParameterList', 'MaxUnpool3d', 'LazyConv2d', 'Conv2d', 'EmbeddingBag', 'MaxPool3d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.prelu = nn.PReLU()
        self.max_unpool2d = nn.MaxUnpool2d(kernel_size=2, stride=2)
        self.parameter_list = nn.ParameterList([nn.Parameter(torch.randn(10)) for _ in range(3)])
        self.max_unpool3d = nn.MaxUnpool3d(kernel_size=2, stride=2)
        self.lazy_conv2d = nn.LazyConv2d(out_channels=16, kernel_size=3)
        self.conv2d = nn.Conv2d(16, 32, kernel_size=3)
        self.embedding_bag = nn.EmbeddingBag(num_embeddings=100, embedding_dim=32, mode='mean')
        self.max_pool3d = nn.MaxPool3d(kernel_size=2, stride=2)

    def forward(self, x):
        # Assuming x is a 4D tensor (batch, channels, height, width)
        x = self.prelu(x)
        x = self.lazy_conv2d(x)
        x = self.conv2d(x)
        
        # MaxPool2d and MaxUnpool2d require indices, so we need to perform MaxPool2d first
        pool_output, indices = F.max_pool2d(x, kernel_size=2, stride=2, return_indices=True)
        x = self.max_unpool2d(pool_output, indices)
        
        # Reshape for 3D operations
        x = x.unsqueeze(2)  # Add a depth dimension
        x = self.max_pool3d(x)
        x = self.max_unpool3d(x, indices=torch.zeros_like(x, dtype=torch.long))  # Dummy indices for simplicity
        
        # Flatten for embedding bag
        x = x.view(x.size(0), -1)  # Flatten all dimensions except batch
        x = self.embedding_bag(torch.arange(0, x.size(1), dtype=torch.long).unsqueeze(0).to(x.device), x)
        
        # Apply parameter list
        for param in self.parameter_list:
            x = x + param.unsqueeze(0)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 64, 64).cuda()  # Example input shape
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


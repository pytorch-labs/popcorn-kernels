
# This is a random torch model generated by the following modules: ['ConstantPad1d', 'ReflectionPad3d', 'MultiLabelMarginLoss', 'AdaptiveLogSoftmaxWithLoss', 'ConvTranspose3d', 'PairwiseDistance']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.pad1d = nn.ConstantPad1d(padding=2, value=3)
        self.pad3d = nn.ReflectionPad3d(padding=1)
        self.conv_transpose3d = nn.ConvTranspose3d(in_channels=1, out_channels=3, kernel_size=3, stride=2, padding=1)
        self.pairwise_distance = nn.PairwiseDistance(p=2)
        self.adaptive_log_softmax = nn.AdaptiveLogSoftmaxWithLoss(in_features=10, n_classes=5, cutoffs=[2, 4])
        self.multi_label_margin_loss = nn.MultiLabelMarginLoss()

    def forward(self, x):
        # Apply ConstantPad1d
        x = x.view(x.size(0), x.size(1), -1)  # Reshape to 3D tensor for ConstantPad1d
        x = self.pad1d(x)
        
        # Reshape back to 5D tensor for ReflectionPad3d
        x = x.view(x.size(0), x.size(1), x.size(2), 1, 1)
        x = self.pad3d(x)
        
        # Apply ConvTranspose3d
        x = self.conv_transpose3d(x)
        
        # Compute PairwiseDistance
        x = x.view(x.size(0), -1)  # Flatten for PairwiseDistance
        x = self.pairwise_distance(x, torch.zeros_like(x))  # Compare with zeros
        
        # Apply AdaptiveLogSoftmaxWithLoss
        x = x.view(x.size(0), -1)  # Ensure correct shape for AdaptiveLogSoftmax
        x = self.adaptive_log_softmax(x, torch.zeros(x.size(0), dtype=torch.long))[0]
        
        # Apply MultiLabelMarginLoss
        x = x.view(x.size(0), -1)  # Ensure correct shape for MultiLabelMarginLoss
        x = self.multi_label_margin_loss(x, torch.zeros(x.size(0), 5, dtype=torch.long))
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 1, 10, 10, 10).cuda()  # Arbitrary input shape
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


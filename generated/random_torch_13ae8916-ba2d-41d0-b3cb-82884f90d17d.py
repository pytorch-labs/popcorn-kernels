
# This is a random torch model generated by the following modules: ['TripletMarginLoss', 'EmbeddingBag', 'LeakyReLU']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self, num_embeddings=1000, embedding_dim=128) -> None:
        super().__init__()
        self.embedding_bag = nn.EmbeddingBag(num_embeddings, embedding_dim, mode='mean')
        self.leaky_relu = nn.LeakyReLU(negative_slope=0.1)
        self.triplet_loss = nn.TripletMarginLoss(margin=1.0, p=2)

    def forward(self, x):
        # Assuming x is a tensor of indices for EmbeddingBag
        x = self.embedding_bag(x)
        x = self.leaky_relu(x)
        
        # For TripletMarginLoss, we need anchor, positive, and negative samples
        # Here, we split the output into three parts for demonstration purposes
        anchor, positive, negative = x.chunk(3, dim=0)
        
        # Compute the triplet loss
        loss = self.triplet_loss(anchor, positive, negative)
        
        return loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    # Assuming input is a tensor of indices for EmbeddingBag
    x = torch.randint(0, 1000, (300,)).cuda()  # 300 indices for embedding bag
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


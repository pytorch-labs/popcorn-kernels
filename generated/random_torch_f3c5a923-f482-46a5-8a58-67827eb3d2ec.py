
# This is a random torch model generated by the following modules: ['LSTMCell', 'CTCLoss', 'PairwiseDistance', 'AdaptiveMaxPool2d', 'Conv2d', 'ConvTranspose2d', 'CircularPad1d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.conv1 = nn.Conv2d(3, 16, kernel_size=3, stride=1, padding=1)
        self.conv_transpose1 = nn.ConvTranspose2d(16, 32, kernel_size=2, stride=2)
        self.adaptive_max_pool = nn.AdaptiveMaxPool2d((16, 16))
        self.lstm_cell = nn.LSTMCell(32 * 16 * 16, 128)
        self.pairwise_distance = nn.PairwiseDistance()
        self.circular_pad = nn.CircularPad1d(1)
        self.ctc_loss = nn.CTCLoss()

    def forward(self, x):
        # Apply Conv2d
        x = self.conv1(x)
        
        # Apply ConvTranspose2d
        x = self.conv_transpose1(x)
        
        # Apply AdaptiveMaxPool2d
        x = self.adaptive_max_pool(x)
        
        # Reshape for LSTMCell
        batch_size = x.size(0)
        x = x.view(batch_size, -1)
        
        # Initialize hidden and cell states for LSTMCell
        hx = torch.zeros(batch_size, 128).to(x.device)
        cx = torch.zeros(batch_size, 128).to(x.device)
        
        # Apply LSTMCell
        hx, cx = self.lstm_cell(x, (hx, cx))
        
        # Apply PairwiseDistance
        x = self.pairwise_distance(hx, cx)
        
        # Reshape for CircularPad1d
        x = x.unsqueeze(1)
        
        # Apply CircularPad1d
        x = self.circular_pad(x)
        
        # Reshape for CTC Loss
        x = x.unsqueeze(0)
        
        # Dummy target for CTC Loss
        target = torch.randint(1, 10, (batch_size, 5), dtype=torch.long).to(x.device)
        target_lengths = torch.full((batch_size,), 5, dtype=torch.long).to(x.device)
        input_lengths = torch.full((batch_size,), x.size(1), dtype=torch.long).to(x.device)
        
        # Apply CTC Loss
        loss = self.ctc_loss(x, target, input_lengths, target_lengths)
        
        return loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 32, 32).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


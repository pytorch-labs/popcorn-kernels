
# This is a random torch model generated by the following modules: ['LayerNorm', 'ReLU', 'Softshrink', 'AdaptiveAvgPool3d', 'CELU', 'NLLLoss2d', 'EmbeddingBag', 'Mish', 'PairwiseDistance', 'Threshold']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.layernorm = nn.LayerNorm(128)
        self.relu = nn.ReLU()
        self.softshrink = nn.Softshrink()
        self.adaptive_avg_pool3d = nn.AdaptiveAvgPool3d((8, 8, 8))
        self.celu = nn.CELU()
        self.embedding_bag = nn.EmbeddingBag(1000, 128, mode='mean')
        self.mish = nn.Mish()
        self.pairwise_distance = nn.PairwiseDistance()
        self.threshold = nn.Threshold(0.5, 1.0)
        self.nll_loss2d = nn.NLLLoss2d()

    def forward(self, x):
        # Assuming x is a 3D tensor (batch_size, sequence_length, embedding_dim)
        x = self.layernorm(x)
        x = self.relu(x)
        x = self.softshrink(x)
        
        # Reshape to 5D tensor for AdaptiveAvgPool3d
        x = x.unsqueeze(2).unsqueeze(3)  # Add dummy dimensions
        x = self.adaptive_avg_pool3d(x)
        
        x = self.celu(x)
        
        # Flatten and reshape for EmbeddingBag
        x = x.view(-1, 8 * 8 * 8)  # Flatten to (batch_size, 512)
        x = self.embedding_bag(x.long())  # Convert to long for embedding
        
        x = self.mish(x)
        
        # PairwiseDistance requires two inputs, so we split x into two halves
        x1, x2 = torch.chunk(x, 2, dim=1)
        x = self.pairwise_distance(x1, x2)
        
        x = self.threshold(x)
        
        # Reshape for NLLLoss2d (assuming 2D input)
        x = x.unsqueeze(0).unsqueeze(0)  # Add batch and channel dimensions
        target = torch.zeros(1, 1, 1, dtype=torch.long)  # Dummy target for NLLLoss2d
        x = self.nll_loss2d(x, target)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(10, 128).cuda()  # Example input shape (batch_size, sequence_length, embedding_dim)
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


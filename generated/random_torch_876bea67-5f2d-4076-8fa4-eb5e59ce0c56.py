
# This is a random torch model generated by the following modules: ['ReplicationPad1d', 'LeakyReLU', 'MaxUnpool1d', 'MaxPool3d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.replication_pad1d = nn.ReplicationPad1d(2)
        self.leaky_relu = nn.LeakyReLU(0.1)
        self.max_pool3d = nn.MaxPool3d(kernel_size=2, return_indices=True)
        self.max_unpool1d = nn.MaxUnpool1d(kernel_size=2)
        
    def forward(self, x):
        # Assuming input is 3D (batch_size, channels, depth)
        x = self.replication_pad1d(x)  # Apply ReplicationPad1d
        x = self.leaky_relu(x)  # Apply LeakyReLU
        
        # Reshape to 5D (batch_size, channels, depth, height, width) for MaxPool3d
        x = x.unsqueeze(-1).unsqueeze(-1)  # Add dummy height and width dimensions
        x, indices = self.max_pool3d(x)  # Apply MaxPool3d
        
        # Reshape back to 3D (batch_size, channels, depth) for MaxUnpool1d
        x = x.squeeze(-1).squeeze(-1)  # Remove dummy height and width dimensions
        x = self.max_unpool1d(x, indices)  # Apply MaxUnpool1d
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 64).cuda()  # Example input: (batch_size=1, channels=3, depth=64)
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


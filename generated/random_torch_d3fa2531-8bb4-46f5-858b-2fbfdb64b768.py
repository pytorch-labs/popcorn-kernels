
# This is a random torch model generated by the following modules: ['BCELoss', 'Softmax', 'ParameterList', 'ConvTranspose3d', 'ConstantPad2d', 'MaxUnpool1d', 'PairwiseDistance', 'Linear', 'Upsample']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.conv_transpose3d = nn.ConvTranspose3d(1, 10, kernel_size=3, stride=2, padding=1)
        self.constant_pad2d = nn.ConstantPad2d(2, 3.5)
        self.max_unpool1d = nn.MaxUnpool1d(kernel_size=2, stride=2)
        self.linear1 = nn.Linear(100, 50)
        self.linear2 = nn.Linear(50, 10)
        self.upsample = nn.Upsample(scale_factor=2, mode='nearest')
        self.parameter_list = nn.ParameterList([nn.Parameter(torch.randn(10)) for _ in range(5)])
        self.pairwise_distance = nn.PairwiseDistance(p=2)
        self.softmax = nn.Softmax(dim=1)
        self.bce_loss = nn.BCELoss()

    def forward(self, x):
        # Apply ConvTranspose3d
        x = self.conv_transpose3d(x)
        
        # Reshape for ConstantPad2d
        x = x.view(x.size(0), x.size(1), x.size(2), -1)
        x = self.constant_pad2d(x)
        
        # Reshape for MaxUnpool1d
        x = x.view(x.size(0), x.size(1), -1)
        indices = torch.arange(0, x.size(2), 2).repeat(x.size(0), x.size(1), 1).to(x.device)
        x = self.max_unpool1d(x, indices)
        
        # Reshape for Linear layers
        x = x.view(x.size(0), -1)
        x = F.relu(self.linear1(x))
        x = self.linear2(x)
        
        # Apply Upsample
        x = x.unsqueeze(2).unsqueeze(3)
        x = self.upsample(x)
        
        # Apply ParameterList
        for param in self.parameter_list:
            x = x + param.view(1, -1, 1, 1)
        
        # Apply PairwiseDistance
        x = x.view(x.size(0), -1)
        x = self.pairwise_distance(x, torch.zeros_like(x))
        
        # Apply Softmax
        x = self.softmax(x.unsqueeze(1))
        
        # Apply BCELoss (assuming a target tensor for demonstration)
        target = torch.zeros_like(x)
        loss = self.bce_loss(x, target)
        
        return loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 1, 16, 16, 16).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

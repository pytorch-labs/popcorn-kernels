
# This is a random torch model generated by the following modules: ['ModuleList', 'RNNCellBase', 'ReflectionPad1d', 'GRUCell', 'AvgPool1d', 'TripletMarginWithDistanceLoss', 'CircularPad1d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.module_list = nn.ModuleList([
            nn.RNNCellBase(input_size=10, hidden_size=20),
            nn.GRUCell(input_size=20, hidden_size=30),
            nn.ReflectionPad1d(padding=2),
            nn.CircularPad1d(padding=2),
            nn.AvgPool1d(kernel_size=2),
            nn.RNNCellBase(input_size=30, hidden_size=40),
            nn.GRUCell(input_size=40, hidden_size=50),
            nn.ReflectionPad1d(padding=2),
            nn.CircularPad1d(padding=2),
            nn.AvgPool1d(kernel_size=2),
        ])
        self.loss_fn = nn.TripletMarginWithDistanceLoss(distance_function=lambda x, y: F.pairwise_distance(x, y, p=2))

    def forward(self, x):
        # Assuming x is of shape (batch_size, sequence_length, input_size)
        batch_size, sequence_length, input_size = x.shape
        
        # Initialize hidden states for RNN and GRU cells
        h_rnn1 = torch.zeros(batch_size, 20).to(x.device)
        h_gru1 = torch.zeros(batch_size, 30).to(x.device)
        h_rnn2 = torch.zeros(batch_size, 40).to(x.device)
        h_gru2 = torch.zeros(batch_size, 50).to(x.device)
        
        # Process through the ModuleList
        for i, module in enumerate(self.module_list):
            if isinstance(module, nn.RNNCellBase):
                if i == 0:
                    h_rnn1 = module(x[:, 0, :], h_rnn1)
                else:
                    h_rnn2 = module(x[:, 0, :], h_rnn2)
            elif isinstance(module, nn.GRUCell):
                if i == 1:
                    h_gru1 = module(h_rnn1, h_gru1)
                else:
                    h_gru2 = module(h_rnn2, h_gru2)
            elif isinstance(module, (nn.ReflectionPad1d, nn.CircularPad1d)):
                x = module(x)
            elif isinstance(module, nn.AvgPool1d):
                x = module(x)
        
        # Compute triplet loss using the final hidden states
        anchor = h_gru1
        positive = h_gru2
        negative = torch.zeros_like(anchor).uniform_(-1, 1)  # Random negative sample
        loss = self.loss_fn(anchor, positive, negative)
        
        return loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 10, 10).cuda()  # (batch_size, sequence_length, input_size)
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

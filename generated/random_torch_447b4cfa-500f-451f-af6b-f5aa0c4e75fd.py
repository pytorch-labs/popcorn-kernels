
# This is a random torch model generated by the following modules: ['SyncBatchNorm', 'L1Loss', 'Unflatten', 'Hardtanh', 'CTCLoss', 'NLLLoss2d', 'MaxPool2d', 'SELU']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.sync_bn = nn.SyncBatchNorm(64)
        self.max_pool = nn.MaxPool2d(kernel_size=2, stride=2)
        self.hardtanh = nn.Hardtanh(min_val=-1.0, max_val=1.0)
        self.selu = nn.SELU()
        self.unflatten = nn.Unflatten(1, (32, 2))
        self.l1_loss = nn.L1Loss()
        self.ctc_loss = nn.CTCLoss()
        self.nll_loss_2d = nn.NLLLoss2d()

    def forward(self, x):
        # Apply SyncBatchNorm
        x = self.sync_bn(x)
        
        # Apply MaxPool2d
        x = self.max_pool(x)
        
        # Apply Hardtanh
        x = self.hardtanh(x)
        
        # Apply SELU
        x = self.selu(x)
        
        # Reshape and Unflatten
        x = x.view(x.size(0), -1)  # Flatten
        x = self.unflatten(x)
        
        # Compute L1Loss (dummy target)
        target = torch.zeros_like(x)
        l1_loss = self.l1_loss(x, target)
        
        # Compute CTCLoss (dummy input and target)
        log_probs = F.log_softmax(x, dim=1)
        input_lengths = torch.full((x.size(0),), x.size(1), dtype=torch.long)
        target_lengths = torch.full((x.size(0),), x.size(1) // 2, dtype=torch.long)
        ctc_loss = self.ctc_loss(log_probs, torch.randint(0, 10, (x.size(0), x.size(1) // 2)), input_lengths, target_lengths)
        
        # Compute NLLLoss2d (dummy target)
        target = torch.randint(0, 10, (x.size(0), x.size(1), x.size(2)))
        nll_loss_2d = self.nll_loss_2d(F.log_softmax(x, dim=1), target)
        
        # Return the losses as a tuple
        return l1_loss, ctc_loss, nll_loss_2d


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 64, 32, 32).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

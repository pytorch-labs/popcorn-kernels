
# This is a random torch model generated by the following modules: ['Tanhshrink', 'TripletMarginLoss', 'ZeroPad1d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.zero_pad1d = nn.ZeroPad1d(padding=2)
        self.tanhshrink = nn.Tanhshrink()
        self.triplet_margin_loss = nn.TripletMarginLoss(margin=1.0, p=2)

    def forward(self, x):
        # Assuming x is of shape (batch_size, channels, length)
        x = self.zero_pad1d(x)  # Apply ZeroPad1d to the input
        x = self.tanhshrink(x)  # Apply Tanhshrink to the padded input
        
        # For TripletMarginLoss, we need three inputs: anchor, positive, and negative
        # Here, we split the input into three parts to simulate anchor, positive, and negative
        batch_size, channels, length = x.shape
        anchor = x[:, :, :length//3]
        positive = x[:, :, length//3:2*length//3]
        negative = x[:, :, 2*length//3:]
        
        # Apply TripletMarginLoss
        loss = self.triplet_margin_loss(anchor, positive, negative)
        
        # Return the loss as the output (since TripletMarginLoss is a loss function)
        return loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 64).cuda()  # Example input: (batch_size=1, channels=3, length=64)
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []



# This is a random torch model generated by the following modules: ['SyncBatchNorm', 'CircularPad2d', 'PoissonNLLLoss', 'Unfold', 'ConvTranspose1d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.conv_transpose1d = nn.ConvTranspose1d(1, 10, kernel_size=5)
        self.sync_batch_norm = nn.SyncBatchNorm(10)
        self.circular_pad2d = nn.CircularPad2d(2)
        self.unfold = nn.Unfold(kernel_size=(3, 3))
        self.poisson_nll_loss = nn.PoissonNLLLoss()

    def forward(self, x):
        # Assuming input is of shape (batch_size, channels, height, width)
        # Reshape to 1D for ConvTranspose1d
        x = x.view(x.size(0), 1, -1)  # Reshape to (batch_size, 1, height * width)
        x = self.conv_transpose1d(x)  # Output shape: (batch_size, 10, height * width + 4)
        x = self.sync_batch_norm(x)  # SyncBatchNorm on the output
        x = x.view(x.size(0), 10, x.size(2) // 10, 10)  # Reshape back to 4D for CircularPad2d
        x = self.circular_pad2d(x)  # Apply circular padding
        x = self.unfold(x)  # Unfold the tensor
        x = x.mean(dim=1, keepdim=True)  # Reduce dimensions for PoissonNLLLoss
        target = torch.ones_like(x)  # Dummy target for PoissonNLLLoss
        loss = self.poisson_nll_loss(x, target)  # Compute PoissonNLLLoss
        return loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 1, 64, 64).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

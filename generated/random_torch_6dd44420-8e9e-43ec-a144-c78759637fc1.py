
# This is a random torch model generated by the following modules: ['Linear', 'ModuleList', 'CosineSimilarity', 'CrossEntropyLoss']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.linear_layers = nn.ModuleList([nn.Linear(128, 256), nn.Linear(256, 128)])
        self.cosine_sim = nn.CosineSimilarity(dim=1)
        self.cross_entropy_loss = nn.CrossEntropyLoss()

    def forward(self, x):
        # Flatten the input to fit the linear layers
        x = x.view(x.size(0), -1)
        
        # Pass through the linear layers
        for layer in self.linear_layers:
            x = F.relu(layer(x))
        
        # Split the output into two tensors for cosine similarity
        x1, x2 = x.chunk(2, dim=1)
        
        # Compute cosine similarity
        cosine_sim = self.cosine_sim(x1, x2)
        
        # Compute cross-entropy loss (dummy target for demonstration)
        target = torch.randint(0, 2, (x.size(0),), device=x.device)
        loss = self.cross_entropy_loss(cosine_sim.unsqueeze(0), target.unsqueeze(0))
        
        return loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 128).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


# This is a random torch model generated by the following modules: ['Sigmoid', 'BCELoss', 'CircularPad3d', 'MaxPool1d', 'GaussianNLLLoss', 'PoissonNLLLoss', 'RNNCell', 'LazyBatchNorm2d', 'UpsamplingNearest2d', 'LazyConvTranspose1d']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.circular_pad = nn.CircularPad3d(1)
        self.max_pool = nn.MaxPool1d(kernel_size=2)
        self.rnn_cell = nn.RNNCell(input_size=10, hidden_size=20)
        self.lazy_batch_norm = nn.LazyBatchNorm2d()
        self.upsample = nn.UpsamplingNearest2d(scale_factor=2)
        self.lazy_conv_transpose = nn.LazyConvTranspose1d(out_channels=10, kernel_size=3)
        self.sigmoid = nn.Sigmoid()
        self.bce_loss = nn.BCELoss()
        self.gaussian_nll_loss = nn.GaussianNLLLoss()
        self.poisson_nll_loss = nn.PoissonNLLLoss()

    def forward(self, x):
        # Apply CircularPad3d
        x = self.circular_pad(x)
        
        # Reshape for MaxPool1d
        x = x.view(x.size(0), x.size(1), -1)
        x = self.max_pool(x)
        
        # Reshape for RNNCell
        x = x.view(x.size(0), -1)
        hx = torch.zeros(x.size(0), 20).to(x.device)
        x = self.rnn_cell(x, hx)
        
        # Reshape for LazyBatchNorm2d
        x = x.view(x.size(0), -1, 5, 5)
        x = self.lazy_batch_norm(x)
        
        # Apply UpsamplingNearest2d
        x = self.upsample(x)
        
        # Reshape for LazyConvTranspose1d
        x = x.view(x.size(0), x.size(1), -1)
        x = self.lazy_conv_transpose(x)
        
        # Apply Sigmoid
        x = self.sigmoid(x)
        
        # Compute BCELoss (dummy target)
        target = torch.rand_like(x)
        bce_loss = self.bce_loss(x, target)
        
        # Compute GaussianNLLLoss (dummy target and var)
        target_gaussian = torch.rand_like(x)
        var = torch.ones_like(x)
        gaussian_loss = self.gaussian_nll_loss(x, target_gaussian, var)
        
        # Compute PoissonNLLLoss (dummy target)
        target_poisson = torch.rand_like(x)
        poisson_loss = self.poisson_nll_loss(x, target_poisson)
        
        # Return the losses as a tuple
        return bce_loss, gaussian_loss, poisson_loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 32, 32, 32).cuda()  # Arbitrary input shape
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

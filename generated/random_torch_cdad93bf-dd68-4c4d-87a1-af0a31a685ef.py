
# This is a random torch model generated by the following modules: ['BatchNorm1d', 'ReLU6', 'TripletMarginLoss', 'AlphaDropout', 'SELU', 'Embedding', 'Softshrink', 'PixelShuffle', 'GLU']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.embedding = nn.Embedding(1000, 128)  # Assuming vocab size of 1000
        self.bn1 = nn.BatchNorm1d(128)
        self.glu = nn.GLU(dim=1)
        self.alpha_dropout = nn.AlphaDropout(p=0.5)
        self.selu = nn.SELU()
        self.softshrink = nn.Softshrink(lambd=0.5)
        self.pixel_shuffle = nn.PixelShuffle(2)
        self.relu6 = nn.ReLU6()
        self.bn2 = nn.BatchNorm1d(32)
        self.triplet_loss = nn.TripletMarginLoss(margin=1.0, p=2)

    def forward(self, x):
        # Assuming x is a tensor of indices for embedding
        x = self.embedding(x)
        x = x.view(-1, 128)  # Reshape for BatchNorm1d
        x = self.bn1(x)
        x = x.view(-1, 256, 1, 1)  # Reshape for GLU
        x = self.glu(x)
        x = x.view(-1, 128)  # Reshape for AlphaDropout
        x = self.alpha_dropout(x)
        x = self.selu(x)
        x = self.softshrink(x)
        x = x.view(-1, 128, 1, 1)  # Reshape for PixelShuffle
        x = self.pixel_shuffle(x)
        x = x.view(-1, 32)  # Reshape for ReLU6
        x = self.relu6(x)
        x = self.bn2(x)
        
        # TripletMarginLoss requires three inputs: anchor, positive, negative
        anchor = x[:x.size(0)//3]
        positive = x[x.size(0)//3:2*x.size(0)//3]
        negative = x[2*x.size(0)//3:]
        loss = self.triplet_loss(anchor, positive, negative)
        
        return loss


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randint(0, 1000, (300,)).cuda()  # 300 indices for embedding
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


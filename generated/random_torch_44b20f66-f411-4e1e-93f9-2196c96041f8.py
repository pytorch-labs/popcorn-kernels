
# This is a random torch model generated by the following modules: ['Container', 'PairwiseDistance', 'MaxPool2d', 'TripletMarginWithDistanceLoss', 'PoissonNLLLoss', 'HuberLoss', 'SoftMarginLoss', 'ConstantPad3d', 'Hardtanh', 'Tanh']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.container = nn.Sequential(
            nn.MaxPool2d(kernel_size=2, stride=2),
            nn.ConstantPad3d(padding=(1, 1, 1, 1, 1, 1), value=0),
            nn.Hardtanh(min_val=-1, max_val=1),
            nn.Tanh(),
            nn.MaxPool2d(kernel_size=2, stride=2),
            nn.ConstantPad3d(padding=(1, 1, 1, 1, 1, 1), value=0),
            nn.Hardtanh(min_val=-1, max_val=1),
            nn.Tanh(),
        )
        self.pairwise_distance = nn.PairwiseDistance(p=2)
        self.triplet_loss = nn.TripletMarginWithDistanceLoss(distance_function=lambda x, y: self.pairwise_distance(x, y))
        self.poisson_loss = nn.PoissonNLLLoss(log_input=True)
        self.huber_loss = nn.HuberLoss()
        self.softmargin_loss = nn.SoftMarginLoss()

    def forward(self, x):
        # Apply the container module
        x = self.container(x)
        
        # Reshape the output to fit the PairwiseDistance input
        x = x.view(x.size(0), -1)
        
        # Create anchor, positive, and negative samples for TripletMarginWithDistanceLoss
        anchor = x[:x.size(0)//2]
        positive = x[x.size(0)//2:]
        negative = torch.flip(anchor, dims=[0])
        
        # Compute the triplet loss
        triplet_loss = self.triplet_loss(anchor, positive, negative)
        
        # Compute the PoissonNLLLoss
        poisson_loss = self.poisson_loss(x, torch.ones_like(x))
        
        # Compute the HuberLoss
        huber_loss = self.huber_loss(x, torch.zeros_like(x))
        
        # Compute the SoftMarginLoss
        softmargin_loss = self.softmargin_loss(x, torch.ones_like(x))
        
        # Return the average of all losses
        return (triplet_loss + poisson_loss + huber_loss + softmargin_loss) / 4


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 64, 64).cuda()
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []


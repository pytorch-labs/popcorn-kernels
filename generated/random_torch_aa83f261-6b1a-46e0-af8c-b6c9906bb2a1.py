
# This is a random torch model generated by the following modules: ['LogSigmoid', 'CTCLoss', 'ZeroPad3d', 'GRUCell', 'AdaptiveMaxPool3d', 'PixelUnshuffle', 'Linear', 'BatchNorm1d', 'CrossEntropyLoss']
import torch
import torch.nn as nn
import torch.nn.functional as F


class Model(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.zero_pad = nn.ZeroPad3d(1)
        self.pixel_unshuffle = nn.PixelUnshuffle(2)
        self.adaptive_max_pool = nn.AdaptiveMaxPool3d((8, 8, 8))
        self.gru_cell = nn.GRUCell(512, 256)
        self.linear1 = nn.Linear(256, 128)
        self.batch_norm = nn.BatchNorm1d(128)
        self.linear2 = nn.Linear(128, 10)
        self.log_sigmoid = nn.LogSigmoid()
        self.ctc_loss = nn.CTCLoss()
        self.cross_entropy_loss = nn.CrossEntropyLoss()

    def forward(self, x):
        # ZeroPad3d
        x = self.zero_pad(x)
        
        # PixelUnshuffle
        x = self.pixel_unshuffle(x)
        
        # AdaptiveMaxPool3d
        x = self.adaptive_max_pool(x)
        
        # Reshape for GRUCell
        batch_size = x.size(0)
        x = x.view(batch_size, -1)  # Flatten all dimensions except batch
        
        # GRUCell
        hx = torch.zeros(batch_size, 256).to(x.device)
        x = self.gru_cell(x, hx)
        
        # Linear
        x = self.linear1(x)
        
        # BatchNorm1d
        x = self.batch_norm(x)
        
        # Linear
        x = self.linear2(x)
        
        # LogSigmoid
        x = self.log_sigmoid(x)
        
        # CTC Loss (assuming targets and input lengths are provided)
        # For demonstration, we'll just return the log probabilities
        # In practice, you would compute the loss here
        # loss = self.ctc_loss(x, targets, input_lengths, target_lengths)
        
        # CrossEntropyLoss (assuming targets are provided)
        # For demonstration, we'll just return the log probabilities
        # In practice, you would compute the loss here
        # loss = self.cross_entropy_loss(x, targets)
        
        return x


def get_inputs():
    # randomly generate input tensors based on the model architecture
    x = torch.randn(1, 3, 16, 16, 16).cuda()  # Example input shape
    return [x]

def get_init_inputs():
    # randomly generate tensors required for initialization based on the model architecture
    return []

